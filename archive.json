{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2022-04-03T18:23:55.741280+00:00",
  "repo": "quicwg/datagram",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "editorial",
      "description": "",
      "color": "e99695"
    },
    {
      "name": "auth48",
      "description": "Issues from AUTH48",
      "color": "54F2B9"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "MDU6SXNzdWU1NzIyMzgwODE=",
      "title": "remind implementors of the \"fun\" parts of no flow control",
      "url": "https://github.com/quicwg/datagram/issues/1",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Flow control is painful because getting it wrong is painful.\r\n\r\nNot having flow control doesn't mean having it done right!\r\n\r\nWould be great to have a brief reminder around this in the draft!\r\n\r\n(Issue copied from [individual draft repo](https://github.com/tfpauly/draft-pauly-quic-datagram/issues/33), by @grmocg on 2019-11-19)",
      "createdAt": "2020-02-27T17:27:58Z",
      "updatedAt": "2021-07-20T21:42:57Z",
      "closedAt": "2021-07-20T21:42:57Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I expect this may be covered when we add text for #15",
          "createdAt": "2021-03-04T15:06:02Z",
          "updatedAt": "2021-03-04T15:08:32Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I believe this should be covered sufficiently now with the current text. Please open a this or a new issue if you disagree!",
          "createdAt": "2021-07-20T21:42:57Z",
          "updatedAt": "2021-07-20T21:42:57Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "MDU6SXNzdWU1NzIyMzk0OTQ=",
      "title": "Consider retransmission bit leakage",
      "url": "https://github.com/quicwg/datagram/issues/2",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Rephrasing what I mentioned at the mic, imagine a scenario where an application uses DATAGRAM to send a single fixed message (\"fire the missile\"). An adversary on path can start selectively dropping packets and checking to see whether or not they're retransmitted to learn whether or not this special message was sent. (Retransmission detection could be done by looking at the size of the QUIC packet carrying the DATAGRAM, for example.)\r\n\r\nI don't claim this is easy to do in practice, or useful, but I think it does raise interesting questions about how this new frame affects QUIC's security posture. Perhaps some text in the security considerations is needed?\r\n\r\n(Issue copied from [individual draft repo](https://github.com/tfpauly/draft-pauly-quic-datagram/issues/32), by @chris-wood on 2019-11-19)",
      "createdAt": "2020-02-27T17:30:15Z",
      "updatedAt": "2021-07-21T15:44:18Z",
      "closedAt": "2021-07-21T15:44:18Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "[Comment](https://github.com/tfpauly/draft-pauly-quic-datagram/issues/32#issuecomment-589646535) from @mikkelfj on 2020-02-21:\r\n\r\nHow would that be different from streams in ordinary QUIC? Here you can also drop packets and look for retransmissions of a specific size? If there is overlap, this issue belongs to QUIC transport security considerations in general.",
          "createdAt": "2020-02-27T17:32:57Z",
          "updatedAt": "2020-02-27T17:32:57Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "I think the key here is that, in dropping the special datagram frame and *not* seeing anything retransmitted, one could learn something about what was sent. ",
          "createdAt": "2020-02-27T17:39:56Z",
          "updatedAt": "2020-02-27T17:39:56Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "If we take my recommendation in #8 to always at least send out a PING frame/packet for PTOs or losses of DATAGRAM frame/packets then, it may mitigate this leakage some. There would always be something sent out on these selective losses. I'm not sure how hard it would be to determine if the lost packet was a DATAGRAM or not with this behavior. My guess is that it would be implementation dependent.",
          "createdAt": "2020-05-07T16:35:37Z",
          "updatedAt": "2020-05-07T16:35:37Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "PING doesn't really cut it here, because presence and size matter.",
          "createdAt": "2021-03-10T12:34:33Z",
          "updatedAt": "2021-03-10T12:34:33Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Does the attacker have a way of knowing that the packet that was dropped contained a DATAGRAM, vs some other non-retransmitted frame, such as PADDING or PING or ACK?",
          "createdAt": "2021-07-12T18:02:26Z",
          "updatedAt": "2021-07-12T18:02:26Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "Probably not, though I would say that the retransmission logic for those three frames could be different enough that the choice of frame might leak.\r\n\r\nNothing much doing here, though we might note that retransmission logic might expose information that can be used for traffic analysis.",
          "createdAt": "2021-07-12T22:51:59Z",
          "updatedAt": "2021-07-12T22:51:59Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "MDU6SXNzdWU1NzIyMzk1MDg=",
      "title": "Specify Max Payload Size instead of Max Frame Size",
      "url": "https://github.com/quicwg/datagram/issues/3",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Right now, the TP specifies a maximum frame size, including frame type, length and payload. This makes certain values invalid (0, 1?). Also, since this values practically is a kind of flow control, indicating how much data I'm willing to receive at a time, it's the payload length that's important here, not the framing.\r\n\r\nFor these reasons, I'm arguing to change this to specifying a maximum payload length. Then, the question of what a value of zero means. Should a value of 0 be the same thing as not present or should it mean that only 0 length datagrams are allowed? I think it is simpler to say that a value of zero is the same as not present (i.e. disabled).\r\n\r\n(Issue copied from [individual draft repo](https://github.com/tfpauly/draft-pauly-quic-datagram/issues/30), by @nibanks on 2019-11-18)",
      "createdAt": "2020-02-27T17:30:16Z",
      "updatedAt": "2021-07-06T04:35:59Z",
      "closedAt": "2021-07-06T04:35:59Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "[Comment](https://github.com/tfpauly/draft-pauly-quic-datagram/issues/30#issuecomment-555278937) from @Ralith on 2019-11-18:\r\n\r\nWasn't the legality of zero-length frames agreed upon in https://github.com/tfpauly/draft-pauly-quic-datagram/issues/19?\r\n\r\nI didn't even realize that the parameter wasn't payload size. Strongly agree that it should be.",
          "createdAt": "2020-02-27T17:34:34Z",
          "updatedAt": "2020-02-27T17:34:34Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "[Comment](https://github.com/tfpauly/draft-pauly-quic-datagram/issues/30#issuecomment-555436658) from @mikkelfj on 2019-11-19:\r\n\r\nI agree that is simpler to define zero to mean not allowed, but it is highly confusing to be forced to require a length of one if you specifically only use 0 length datagrams for heatbeats or similar. It would be better to a have separate indicator to reject datagrams altogether.",
          "createdAt": "2020-02-27T17:35:26Z",
          "updatedAt": "2020-02-27T17:35:26Z"
        },
        {
          "author": "Ralith",
          "authorAssociation": "NONE",
          "body": "> It would be better to a have separate indicator to reject datagrams altogether.\r\n\r\nIsn't this indicated by omitting the transport parameter entirely?",
          "createdAt": "2020-02-28T03:56:13Z",
          "updatedAt": "2020-02-28T03:56:13Z"
        },
        {
          "author": "mikkelfj",
          "authorAssociation": "NONE",
          "body": "@Ralith If omitting the parameter indicates that data frames are not permitted, then this achieves the purpose, yes. So there is no need to have 0 means disabling. Hence it is better to have 0 mean 0 length, but still valid. This is the most natural representation, and there is a an actual meaning ful use of these, namely heartbeats. Further, by making it explicit that length 0 is the only valid, you can have a fast or lightweight implementation.",
          "createdAt": "2020-03-05T09:39:05Z",
          "updatedAt": "2020-03-05T09:39:05Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I wonder if we need this limit at all. It introduces implementation complexity and it's unclear why any implementation would like to limit the size of DATAGRAM frames (or payloads) they can receive. We already have `max_packet_size` for implementations that have a limit on their stack size.\r\n\r\nDoes anyone have a use-case where they'd like to limit the size of DATAGRAM frames (or payloads) specifically?",
          "createdAt": "2020-05-08T22:35:31Z",
          "updatedAt": "2020-05-08T22:35:31Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "I'm all for removing the limit. As I have it coded up in MsQuic, I always send a max value. It's not even configurable by the app. I don't think \"I have a buffering limit\" a good reason to have a limit. It's limited by a single packet already. That should be enough IMO.",
          "createdAt": "2020-05-08T22:38:07Z",
          "updatedAt": "2020-05-08T22:38:07Z"
        },
        {
          "author": "Ralith",
          "authorAssociation": "NONE",
          "body": "I don't think it's particularly useful to set this smaller than a packet, given that a reasonable buffer is bigger than that, and I'm not sure what a peer could usefully do with the information that the limit is larger than a packet. :+1:",
          "createdAt": "2020-05-08T22:40:23Z",
          "updatedAt": "2020-05-08T22:40:23Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "The more I think about it, limiting the size of the QUIC DATAGRAMS (frames or payloads) is weird. In part because there is no wiresignal to describe a max number of DATAGRAMS per packet, and we seem to have discounted the need for an internal API to configure how frames are composed in a packet. I don't hear anyone with use cases; removing the limit removes a whole load of edge cases and/or implementation defined behaviour. I think the simplification would be a win.",
          "createdAt": "2020-05-13T18:19:08Z",
          "updatedAt": "2020-05-13T18:19:08Z"
        },
        {
          "author": "mikkelfj",
          "authorAssociation": "NONE",
          "body": "@DavidSchinazi One reason you might want to limit Datagrams is if you have a slottet buffering system for datagrams, for example 1K, or 256 bytes per datagram, or a paged system of multiple datagrams. In this case you cannot always fit a whole package into the buffering. For streams you have an entirely different mechanism, and other frames are generally not large.",
          "createdAt": "2020-06-10T07:56:29Z",
          "updatedAt": "2020-06-10T07:56:29Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mikkelfj that's an interesting thought - is this something you're planning on implementing and have a use for, or is it more of a thought experiment?",
          "createdAt": "2020-06-10T19:10:21Z",
          "updatedAt": "2020-06-10T19:10:21Z"
        },
        {
          "author": "mikkelfj",
          "authorAssociation": "NONE",
          "body": "@DavidSchinazi Unfortunately I've had to push back on my QUIC dev, but I did work with an emulation of netmap, on top of select / poll, that uses slots to receive packets from the OS without context switching. Sometimes a packet needs to span multiple slots, but often it just drops into a 2K slot or so. I could imagine many use cases where datagrams are redistributed to other threads or processes in a similar manner without having an explicit use case. I believe there are now several kernel interfaces that uses a similar approach.",
          "createdAt": "2020-06-10T19:43:41Z",
          "updatedAt": "2020-06-10T19:43:41Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As far as I know, those kernel interfaces all use slots that are larger than the interface MTU, so I don't think they'd require reducing the payload size. Am I missing something?",
          "createdAt": "2020-06-10T20:13:12Z",
          "updatedAt": "2020-06-10T20:13:12Z"
        },
        {
          "author": "mikkelfj",
          "authorAssociation": "NONE",
          "body": "Well, I can only speak for netmap, but it works by having the user specify one large memory block divided into a number of equal sized slots of a user specified size. Each slot has a control record with some flags. A record can indicate that the slot is partial and reference the next slot in the packet. So you can can choose a slot of 64K and waste a lot of memory, or choose a slot of 512 bytes and frequently have to deal with fragmenting. Or chose 2K for a use case where you know that you will not have larger payload and can afford the space overhead.\r\n\r\nEDIT: to clarify, it is the network driver that chooses to link data and update the control record when receiving, and the user process when writing.\r\n\r\nI'm not sure exactly how the other kernel interfaces behave but from memory it is rather much the same.\r\n\r\nFor QUIC datagrams it is a bit different in that you likely want to avoid fragmentation at all cost due to the added complexity and the non-stream nature of the data. If you could afford fragmentation it would make less sense to have a limit on the size.",
          "createdAt": "2020-06-10T20:20:53Z",
          "updatedAt": "2020-06-10T20:27:09Z"
        },
        {
          "author": "dtikhonov",
          "authorAssociation": "NONE",
          "body": "I support switching to TP specifying max payload size.",
          "createdAt": "2020-08-09T22:46:10Z",
          "updatedAt": "2020-08-09T22:46:10Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "NONE",
          "body": "> I wonder if we need this limit at all. It introduces implementation complexity and it's unclear why any implementation would like to limit the size of DATAGRAM frames (or payloads) they can receive. We already have max_packet_size for implementations that have a limit on their stack size.\r\n\r\nIIRC, the original reason this limit was introduced is to allow QUIC proxies to communicate the max datagram size it gets from the MTU between itself and the backend.",
          "createdAt": "2021-02-26T17:48:50Z",
          "updatedAt": "2021-02-26T17:48:50Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "In my experience, a MASQUE proxy doesn't know that information at the time it opens a listening QUIC connection., and there is nothing to say that all backends would share the same value.",
          "createdAt": "2021-02-26T17:53:25Z",
          "updatedAt": "2021-02-26T17:53:25Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "NONE",
          "body": "This is not for MASQUE, but for a direct QUIC-to-QUIC proxy.",
          "createdAt": "2021-02-26T17:58:35Z",
          "updatedAt": "2021-02-26T17:58:35Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "OK, do you expect the max DATAGRAM frame size a backend expects to receive is smaller than the QUIC packet size it is willing to receive?",
          "createdAt": "2021-02-26T18:09:59Z",
          "updatedAt": "2021-02-26T18:09:59Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If we do have a max frame/perhaps size still defined, perhaps it makes sense to let this be updated by a new frame (MAX_DATAGRAM_SIZE).",
          "createdAt": "2021-03-04T18:07:50Z",
          "updatedAt": "2021-03-04T18:07:50Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A MAX_DATAGRAM_SIZE frame would be tricky because of reordering. In QUIC, all the MAX_FOOBAR frames can only increase limits, but here I suspect for this to be useful we'd want to be able to lower the limit which greatly increases complexity.",
          "createdAt": "2021-03-04T18:17:42Z",
          "updatedAt": "2021-03-04T18:17:42Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "NONE",
          "body": "> OK, do you expect the max DATAGRAM frame size a backend expects to receive is smaller than the QUIC packet size it is willing to receive?\r\n\r\nI expect this to be fairly uncommon, but whenever this does happen, it would make the entire connection unreliable for datagrams, meaning the applications would have to do their own MTU discovery on top of the one QUIC already does.",
          "createdAt": "2021-03-05T15:04:15Z",
          "updatedAt": "2021-03-05T15:04:15Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "The default ought to be \"whatever fits in the PMTU\". ",
          "createdAt": "2021-03-10T12:56:11Z",
          "updatedAt": "2021-03-10T12:56:11Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "Yes, you have to do PMTUD.  (What is pernicious here is that if you get too good at that, the value that you resolve to might not be good forever because your varints will use more bytes over time and so reduce available space.)",
          "createdAt": "2021-03-10T12:58:59Z",
          "updatedAt": "2021-03-10T12:58:59Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinthomson which varints will use more bytes here?",
          "createdAt": "2021-03-10T13:38:02Z",
          "updatedAt": "2021-03-10T13:38:02Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "I was thinking about flow IDs.  If you are not reusing flow IDs, there is a good chance that those will get bigger over time.  But I guess that assumes use of flow IDs.\r\n\r\nMostly, I guess that DATAGRAM can be each sent in their own packet/datagram, so the size of other frames won't affect the space that is available.",
          "createdAt": "2021-03-10T13:45:14Z",
          "updatedAt": "2021-03-10T13:45:14Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah the flow ID is part of the payload as far as this document is concerned.\r\n\r\nOur implementation will try to coalesce DATAGRAM frames with other frames, but that doesn't impact the max possible payload size because if the DATAGRAM frame doesn't fit with other frames we just send it in its own packet.",
          "createdAt": "2021-03-10T13:49:59Z",
          "updatedAt": "2021-03-10T13:49:59Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "MDU6SXNzdWU1ODAyNjYzNzg=",
      "title": "Instances of lowercase \"may\" ",
      "url": "https://github.com/quicwg/datagram/issues/4",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "There are several instances of lowercase \"may\" in this document. It is ambiguous if these are normative requirements or not.",
      "createdAt": "2020-03-12T22:49:28Z",
      "updatedAt": "2021-03-04T14:34:33Z",
      "closedAt": "2021-03-04T14:34:33Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Could you elaborate on why it's ambiguous? We have a reference to RFC 8174.",
          "createdAt": "2020-03-12T22:53:54Z",
          "updatedAt": "2020-03-12T22:53:54Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I sometimes assume typos :) If you're happy the present document is correct, I will close this issue",
          "createdAt": "2020-03-12T23:01:39Z",
          "updatedAt": "2020-03-12T23:01:58Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not aware of errors like this, do you have any specific ones in mind?",
          "createdAt": "2020-03-12T23:53:42Z",
          "updatedAt": "2020-03-12T23:53:42Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Gah, fat fingered accidental close.\r\n\r\nThe example that triggered opening this issue is below, I had to read this several times. Perhaps that's just a sign that editorial tweaks would help, regardless of the exact words in use\r\n\r\n> The risk associated with not providing flow control for DATAGRAM frames is that a receiver may not be able to commit the necessary resources to process the frames. For example, it may not be able to store the frame contents in memory. However, since DATAGRAM frames are inherently unreliable, they MAY be dropped by the receiver if the receiver cannot process them.",
          "createdAt": "2020-03-13T00:01:04Z",
          "updatedAt": "2020-03-13T00:01:04Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I can fix this",
          "createdAt": "2021-03-03T23:30:50Z",
          "updatedAt": "2021-03-03T23:30:50Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "MDU6SXNzdWU1OTE0OTk2NDc=",
      "title": "Anti-affinity for unreliable datagrams",
      "url": "https://github.com/quicwg/datagram/issues/5",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Coming out of some discussion at the WebTransport BoF during IETF 107, @enygren created an issue on the WebTransport API https://github.com/WICG/web-transport/issues/109#issue-589450400:\r\n\r\n> There should be a way to specify that unreliable datagrams do not end up in the same packet, at least when the underlying QUIC or HTTP/3 interface is used. For HTTP/2, an equivalent behavior may be a way to indicate which packets get dropped or thinned when this is needed (eg, to disprefer adjacent packets from being dropped).\r\n\r\nWhile I don't think the DATAGRAM draft itself should concern itself with the API too much, I do wonder if there are some guidance or considerations that could be captured about coalescing of DATAGRAM frames in packets.",
      "createdAt": "2020-03-31T23:17:27Z",
      "updatedAt": "2020-05-07T17:37:25Z",
      "closedAt": "2020-05-07T17:37:25Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure what the value-add is here. Losses are often bursty so having two DATAGRAM frames in the same QUIC packet or in two separate QUIC packets sent back-to-back is likely to produce the same result.",
          "createdAt": "2020-03-31T23:48:02Z",
          "updatedAt": "2020-03-31T23:48:02Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "I tend to agree with @DavidSchinazi here. Assuming tail loss, which usually happens because a node in the path doesn't have enough buffer for in incoming packet that it must forward along, having all the data in one contiguous packet, or two separate, back to back packets would likely result in the same loss pattern.\r\n\r\nEither way, this seems like an implementation design decision (do I expose a knob for this or not?) and not really a spec decision.",
          "createdAt": "2020-05-07T16:41:19Z",
          "updatedAt": "2020-05-07T16:41:19Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "The problem I saw was that, being aware that losses happen and they can be bursty, and that the frames are unrecoverable, there are slightly different tradeoffs when deciding how to pack DATAGRAM frames vs how to pack STREAM frames.\r\n\r\nWhen frames per packet is roughly equal to the packet lost count, there is negligible difference I agree. When the frames-per-packet count gets larger there is greater risk from losses and so I think there is a problem but I've mostly convinced myself that the DATAGRAM draft cannot offer useful specific advice. Application protocols might be able to give specific guidance and there is nothing stopping them from doing so in a different spec,  and implementations will just do whatever they deem most optimal.\r\n\r\nClosing the issue, cheers.",
          "createdAt": "2020-05-07T17:37:25Z",
          "updatedAt": "2020-05-07T17:37:25Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "MDU6SXNzdWU2MDQ4NTYyMjM=",
      "title": "No streams in datagrams?",
      "url": "https://github.com/quicwg/datagram/issues/6",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I finally sat down and read this draft (nice work, BTW) and was somewhat sad to learn that QUIC won't natively support stream multiplexing for datagrams.\r\n\r\nIt is true that applications can implement this if they choose. But one nice thing about QUIC is that it takes care of this machinery on behalf of the application. This is a somewhat aesthetic concern, but it feels awkward to have one layer of stream multiplexing in QUIC and then another layer in the application. It would be ugly in our implementation, at least.\r\n\r\nMoving on to non-aesthetic issues: I don't have a full grasp of all the use cases for DATAGRAM, but if stream multiplexing is a common requirement, it would be good to move this into the transport. Applications that don't need this are free to do it all over one stream at a tiny loss in wire efficiency, or we could have a stream-less version if people are deeply concerned about one byte per frame.",
      "createdAt": "2020-04-22T15:37:41Z",
      "updatedAt": "2021-07-12T02:53:02Z",
      "closedAt": "2021-07-12T02:53:02Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "The argument for taking it out effectively identified that there is little point in putting something in the transport that the transport can't help with",
          "createdAt": "2020-04-22T15:41:31Z",
          "updatedAt": "2020-04-22T15:41:31Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "NONE",
          "body": "While HOL blocking advantages don't apply here, I'm not sure that it's true that the transport couldn't help. For example, a stream construct would make it much easier to handle priority of DATAGRAMs in the send buffer. There are other ways to solve this, but with streams we could use existing QUIC priority APIs.",
          "createdAt": "2020-04-22T15:51:40Z",
          "updatedAt": "2020-04-22T15:51:40Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "In Montreal I also argued for a design that could be used for streaming, but was out numbered at the time. @martinduke, I agree with your opinion that it would be best for the transport to provide this kind of interface, rather than requiring every app/protocol to implement it on top of this extension. I think the best path forward would be make a separate draft for unreliable streams.",
          "createdAt": "2020-04-22T15:56:39Z",
          "updatedAt": "2020-04-22T15:56:39Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I guess I find this prioritization example confusing because the transport protocol doesn't include an expression of the priority on the wire. How does telling the remote endpoint the DATAGRAM flow ID (as we referred to it in previous discussions) help with things that are a concern for transport RX.",
          "createdAt": "2020-04-22T16:04:25Z",
          "updatedAt": "2020-04-22T16:04:25Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "NONE",
          "body": "As with reliable streams, all the priority negotiation is at the application layer and indeed, whether the multiplexing is in the transport or application doesn't matter.\r\n\r\nHowever, in the reliable case it is certainly useful for the transport to have the notion of streams so that it can send the highest-priority streams first. It is certainly possible to build a QUIC API that accepts datagram priority in the absence of transport streams, but it seems a lot more convenient to reuse the existing semantics.\r\n\r\nIf I'm in the rough here, this is not going to break the protocol. But it feels like a recipe for writing a bunch more code.",
          "createdAt": "2020-04-22T16:22:37Z",
          "updatedAt": "2020-04-22T16:22:37Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I do understand what you're saying and it sounds valid but I'm attempting to channel some counter arguments back here. One main services the transport provides for streams is accounting of data stream data flow windows and stream IDs.\r\n\r\nDATAGRAM is attractive to applications that don't require the reliability that streams provide and the lack of a flow ID means it also doesn't come with the overhead of accounting mechanisms that aren't so useful for single-use atomic messages. \r\n\r\nI do think DATAGRAM draft would benefit from some clarification about the expectations of prioritizing DATAGRAM data, especially against STREAMS. But I don't think the flow ID is a requirement for that. \r\n\r\n\r\n",
          "createdAt": "2020-04-22T17:12:31Z",
          "updatedAt": "2020-04-22T17:12:31Z"
        },
        {
          "author": "Ralith",
          "authorAssociation": "NONE",
          "body": "A QUIC implementation could easily provide exactly the same API for managing datagram priority that it does for streams; neither need to be specified in detail by the draft, let alone present on the wire. I don't think adding a field to the wire representation could possibly save any code here; it's *more* complexity for every implementer, not less.",
          "createdAt": "2020-04-22T17:17:56Z",
          "updatedAt": "2020-04-22T17:17:56Z"
        },
        {
          "author": "skissane",
          "authorAssociation": "NONE",
          "body": "I agree with @nibanks point about not requiring every higher level protocol that needs it to separately implement flow IDs. The [Using QUIC Datagrams with HTTP/3](https://tools.ietf.org/html/draft-schinazi-quic-h3-datagram-03) spec provides flow IDs. What if I am designing some new protocol to run on top of QUIC, other than HTTP/3, and I also have the need for multiple datagram flows? If the facility is in QUIC datagrams, then the QUIC library my protocol's implementors will be using is going to provide it to them for free. If the facility is in HTTP/3, few or no HTTP/3 implementations are going to allow just using bits of HTTP/3 in isolation from the rest of it. So it would force the implementors of my higher level protocol to reimplement this facility (or else I might just decide to base my protocol on top of HTTP/3 instead of QUIC \u2013 but that then gets away from the idea that QUIC is usable for more than just HTTP.)\r\n\r\nCouldn't the stuff about flow ID management in the HTTP/3 datagram spec just get moved to this spec instead? ",
          "createdAt": "2020-06-21T09:23:36Z",
          "updatedAt": "2020-06-21T09:23:36Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One of the earlier drafts did have them combined exactly like that. The consensus of the group was to keep them separate. The main issue is that there is nothing at the transport layer that the flow ID influences, only the application. There\u2019s nothing saying APIs can\u2019t make this convenient to use, etc, but it doesn\u2019t necessarily belong in the fundamental wire image of the datagram. ",
          "createdAt": "2020-06-21T21:09:56Z",
          "updatedAt": "2020-06-21T21:09:56Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "To satisfy the flow ID allocation requirement of H3-datagram all that is needed is something like\r\n\r\n```\r\nglobal_flow_id_counter = [0 | 1]; //client even, server odd]\r\n\r\nget_unique_flow_id() {\r\n  r = global_flow_id;\r\n  global_flow_id += 1;\r\n  return r;\r\n}\r\n```\r\n\r\n*How* flow IDs are used is up to the application. And at that point, you're going to really benefit from well-formed application protocol and or/application-mapping. For example, there is no single answer to whether flow IDs are required nor how to bind flow IDs. So, IMO there really not a generic service that a QUIC library can provide to applications.",
          "createdAt": "2020-06-22T10:55:39Z",
          "updatedAt": "2020-06-22T10:55:53Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "> So, IMO there really not a generic service that a QUIC library can provide to applications.\r\n\r\nI personally disagree. The API for a library does more than just implement the protocol. It provides efficient ways to build application logic on top of protocol behavior too. Having the flow-ID at the protocol/library layer allows the API to provide a per-flow abstraction object, similar to a Stream object. This can allow for the app to associate different logic/context to different datagram flows (e.g. register a different receive callback for audio & video flows).\r\n\r\nIMO, this will be a very common usage on top of datagrams and will end up being reimplemented for every app/protocol built on top of datagrams. One of the primary points of the library/API to to implement logic once so that it may be reused for many different apps.\r\n\r\nAdditionally, I don't believe this kind of abstraction layer should be in the library/API unless it's also in the protocol. The goal of the API is to be cross-compatible with other implementations, generically. If my implementation has some custom flow-ID logic, but no other API does, what's the likelihood of interop issues?",
          "createdAt": "2020-06-22T14:43:06Z",
          "updatedAt": "2020-06-22T14:43:06Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I could implement the same behaviour by registering a predicate to the QUIC library e.g. if N bytes of the QUIC DATAGRAM payload matches this pattern, visit this callback function. I don't have that today on the receive side but I do have that for purging pending items in my send queue, see https://github.com/LPardue/quiche/blob/datagram-frame-alt/src/lib.rs#L3090\r\n\r\n> IMO, this will be a very common usage on top of datagrams and will end up being reimplemented for every app/protocol built on top of datagrams. One of the primary points of the library/API to to implement logic once so that it may be reused for many different apps.\r\n\r\n> Additionally, I don't believe this kind of abstraction layer should be in the library/API unless it's also in the protocol. The goal of the API is to be cross-compatible with other implementations, generically. If my implementation has some custom flow-ID logic, but no other API does, what's the likelihood of interop issues?\r\n\r\nI agree. If I added my predicate-style generic method to my QUIC library, I could build on top of it to support the H3-Datagram flow IDs as a first-class API property. It's the job of the application mapping implementation to write the correct predicate, and any additional logic that may be needed such as only accepting flows that have been permitted by some other form of negotiation (such as a CONNECT-UDP method).\r\n\r\nJust adding a flow ID field leaves open a lot of questions, and I don't think they can be answered commonly across all the potential applications.",
          "createdAt": "2020-06-22T15:46:04Z",
          "updatedAt": "2020-06-22T15:46:04Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "From an API perspective, it is certainly useful to have the transport layer help demultiplex and put different flows in different send/receive queues in the application. To that end, I totally agree with you, @nibanks.\r\n\r\nHowever, the diversity of use cases for tracking datagram flows, and the possible ways that this could be usefully exposed to the application, means that building in one interpretation of demultiplexing based on a flow ID without a use for the transport itself may be unnecessarily limiting.\r\n\r\nThis is a common issue for how to do demultiplexing of application flows on top of a transport. In TAPS, we use protocol framers for the same thing, as a way for the application to tell the transport API \"I want to separate messages based on this, and pull out these fields as special markers (like a flow ID)\". (https://www.ietf.org/id/draft-ietf-taps-interface-06.html#name-message-framers) I imagine that a QUIC API should follow this model if it wants to make it easy for datagram applications to demultiplex without having to build their own demux layers.",
          "createdAt": "2020-06-22T16:18:10Z",
          "updatedAt": "2020-06-22T16:18:10Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "NONE",
          "body": "I confess to having a primarily aesthetic objection to having two different\nlayers of stream multiplexing in the stack, but I've been trying to figure\nout a reason streams might matter for the transport. I certainly can't come\nup with a killer app for transport streams. The best I can find are purely\nsend-side, so in theory they can be done with sufficiently rich APIs rather\nthan something on the wire. I guess the question is whether or not this is\ntoo much load to put on the QUIC API:\n\n- Priority. Without a transport-layer stream, the datagram API will have to\nspecify priority on a per-datagram basis.\n- Ordering. The draft should probably say a little more about ordering\nexpectations, but obviously there are no firm guarantees here. I can\ncertainly imagine QUIC reordering datagrams for its own reasons (e.g.\nsending a smaller packet first based on space available), and it might be\ngood for the application to specify that a certain subset of datagrams\nSHOULD be delivered in order. To do this without transport-layer datagram\nstreams, the API would have to provide some sort of datagram identifier\nthat could be ordered with respect to other datagram identifiers. It sounds\nclunky, if this use case could conceivably matter to anyone. Of course, the\nhigher-assurance way to do ordered delivery is to put a sequence number in\nthe application datagram frame and discard OOO datagrams at the receiver.\nbut it would be nice if QUIC didn't make things worse for these\napplications by arbitrary reordering.\n\nMartin\n\n\nOn Mon, Jun 22, 2020 at 9:18 AM Tommy Pauly <notifications@github.com>\nwrote:\n\n> From an API perspective, it is certainly useful to have the transport\n> layer help demultiplex and put different flows in different send/receive\n> queues in the application. To that end, I totally agree with you, @nibanks\n> <https://github.com/nibanks>.\n>\n> However, the diversity of use cases for tracking datagram flows, and the\n> possible ways that this could be usefully exposed to the application, means\n> that building in one interpretation of demultiplexing based on a flow ID\n> without a use for the transport itself may be unnecessarily limiting.\n>\n> This is a common issue for how to do demultiplexing of application flows\n> on top of a transport. In TAPS, we use protocol framers for the same thing,\n> as a way for the application to tell the transport API \"I want to separate\n> messages based on this, and pull out these fields as special markers (like\n> a flow ID)\". (\n> https://www.ietf.org/id/draft-ietf-taps-interface-06.html#name-message-framers)\n> I imagine that a QUIC API should follow this model if it wants to make it\n> easy for datagram applications to demultiplex without having to build their\n> own demux layers.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/quicwg/datagram/issues/6#issuecomment-647625014>, or\n> unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AF2EYEPSTB3HDKXBDQ4IBDLRX575FANCNFSM4MOIZPAQ>\n> .\n>\n",
          "createdAt": "2020-06-22T18:26:55Z",
          "updatedAt": "2020-06-22T18:26:55Z"
        },
        {
          "author": "Ralith",
          "authorAssociation": "NONE",
          "body": "Let's not conflate \"things it would be useful for a QUIC implementation to expose in its API\" with \"things that need to be mandated as part of the wire format.\" There can be discussion of options (not requirements) for the former in the text. Adding extra constraints to the wire format complicates *all* implementations, and makes applications with different requirements awkward.",
          "createdAt": "2020-06-22T22:42:56Z",
          "updatedAt": "2020-06-22T22:42:56Z"
        },
        {
          "author": "Ralith",
          "authorAssociation": "NONE",
          "body": "> To do this without transport-layer datagram streams, the API would have to provide some sort of datagram identifier that could be ordered with respect to other datagram identifiers.\r\n\r\nPurely API-level stream identifiers would work fine for this, as I [discussed previously](https://github.com/quicwg/datagram/issues/6#issuecomment-617914944). This would be pretty convenient and I think is a sensible thing for the draft to suggest (but not require).\r\n\r\nThe datagram extension as currently written is useful in part because it is so content-agnostic; there's plenty of room for more specialized extensions in the future if certain applications would benefit from a more complex wire format.",
          "createdAt": "2020-06-22T22:49:16Z",
          "updatedAt": "2020-06-22T22:49:16Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "NONE",
          "body": "Yes, I agree that would solve the problem.\n\nOn Mon, Jun 22, 2020 at 3:49 PM Benjamin Saunders <notifications@github.com>\nwrote:\n\n> To do this without transport-layer datagram streams, the API would have to\n> provide some sort of datagram identifier that could be ordered with respect\n> to other datagram identifiers.\n>\n> Purely API-level stream identifiers would work fine for this, as I discussed\n> previously\n> <https://github.com/quicwg/datagram/issues/6#issuecomment-617914944>.\n> This would be pretty convenient and I think is a sensible thing for the\n> draft to suggest (but not require).\n>\n> The datagram extension as currently written is useful in part because it\n> is so content-agnostic; there's plenty of room for more specialized\n> extensions in the future if certain applications would benefit from a more\n> complex wire format.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/quicwg/datagram/issues/6#issuecomment-647807171>, or\n> unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AF2EYEMNWFQM3YMTTY4K5SDRX7NXTANCNFSM4MOIZPAQ>\n> .\n>\n",
          "createdAt": "2020-06-22T22:57:00Z",
          "updatedAt": "2020-06-22T22:57:00Z"
        },
        {
          "author": "Ericson2314",
          "authorAssociation": "NONE",
          "body": "I like this status quo. I've been mulling whether in fact all streaming an multiplexing could be done top of a QUIC connection used just for datagrams without loss of QOS. It's certainly not the path taken so far, but I like this datagram extension being pretty minimal to keep the future wider open.",
          "createdAt": "2020-10-07T20:09:44Z",
          "updatedAt": "2020-10-07T20:09:44Z"
        },
        {
          "author": "ekinnear",
          "authorAssociation": "NONE",
          "body": "> Adding extra constraints to the wire format complicates all implementations, and makes applications with different requirements awkward.\r\n@Ralith I'm not sure that's the case here, the original design had an optional flow ID specified by the frame type, IIRC.",
          "createdAt": "2020-10-07T20:49:33Z",
          "updatedAt": "2020-10-07T20:49:33Z"
        },
        {
          "author": "ekinnear",
          "authorAssociation": "NONE",
          "body": "I tend to agree that this is something that almost every user of datagrams is going to need to specify, and being able to interoperate multiple different protocols using datagrams on a single QUIC connection has come up quite a bit. We handled this before by punting it to H3 and saying that you need H3 to be involved to get that mux-ing, but it's been noted in this thread that you might not always have H3 involved.\r\n\r\nPreviously, this led us down into a conversation before we had figured out what alpn meant for QUIC, but at this point I think we've moved past that enough to not want each possible permutation of protocols in use/defined by a new alpn string to have a slightly different mechanism for handling flow identifiers, some of which might be compatible.\r\n\r\nIf we think that introduces too much complexity/other problems to tackle, then right now we've just moved that complexity into H3, which means we (a) still need to solve it, but (b) now everyone else cannot take advantage of that solution.",
          "createdAt": "2020-10-07T20:51:18Z",
          "updatedAt": "2020-10-07T20:51:18Z"
        },
        {
          "author": "ekinnear",
          "authorAssociation": "NONE",
          "body": "To @tfpauly's TAPS comment, I think the question about having an additional [de]mux layer in between is the same as punting it to H3 -- we still need to figure out how to make that work, the question is just where do we group that effort and who can take advantage of it once that work has been done. If everyone always uses datagrams + demux-protocol, then that seems like a not-unreasonable outcome too.",
          "createdAt": "2020-10-07T20:53:41Z",
          "updatedAt": "2020-10-07T20:53:41Z"
        },
        {
          "author": "Ralith",
          "authorAssociation": "NONE",
          "body": ">  @Ralith I'm not sure that's the case here, the original design had an optional flow ID specified by the frame type, IIRC.\r\n\r\nA design decision having been present in a prior draft does not cause it to not be a source of avoidable complication.\r\n\r\n> I tend to agree that this is something that almost every user of datagrams is going to need to specify.\r\n\r\nAs a user of datagrams, I do not need this.",
          "createdAt": "2020-10-08T20:32:51Z",
          "updatedAt": "2020-10-08T20:32:51Z"
        },
        {
          "author": "ekinnear",
          "authorAssociation": "NONE",
          "body": "> A design decision having been present in a prior draft does not cause it to not be a source of avoidable complication.\r\n\r\nHmm, I think the key to the statement above was the _optionality_ of the flow ID, meaning that for use cases that did not require a flow ID, there was no additional space space taken and minimal complexity, since the behavior was exactly as it is today without flow IDs. ",
          "createdAt": "2020-10-14T23:23:59Z",
          "updatedAt": "2020-10-14T23:23:59Z"
        },
        {
          "author": "Ralith",
          "authorAssociation": "NONE",
          "body": "IIRC, support for both modes was mandatory for implementations, i.e. if you negotiated support for the extension during the handshake then you must accept flow IDs. That means it's additional implementation complexity.",
          "createdAt": "2020-10-14T23:42:52Z",
          "updatedAt": "2020-10-14T23:42:52Z"
        },
        {
          "author": "skissane",
          "authorAssociation": "NONE",
          "body": "@Ralith if both modes were brought back, then support for the flow ID extension could be made optional for implementations, so those who didn't want to implement it didn't have to. However, I think in practice, most implementations would implement it if it existed. Optional features in protocols, if sufficiently widely implemented, end up becoming *de facto* mandatory. And if the most common higher level protocols were to require flow IDs (e.g. H3 datagrams), then almost all implementations would implement it even if it were technically optional.",
          "createdAt": "2020-10-15T05:28:11Z",
          "updatedAt": "2020-10-15T21:52:39Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "body": "In the latest H3 QUIC DATAGRAM draft at https://tools.ietf.org/html/draft-schinazi-masque-h3-datagram-04#section-3 (bolding is mine):\r\n\r\n> Implementations of HTTP/3 that support the DATAGRAM extension MUST\r\n   provide a flow identifier allocation service.  That service will\r\n   allow **applications co-located with HTTP/3 to request a unique flow\r\n   identifier** that they can subsequently use for their own purposes.\r\n   The HTTP/3 implementation will then parse the flow identifier of\r\n   incoming DATAGRAM frames and use it to deliver the frame to the\r\n   appropriate application.\r\n\r\nI think this is an important point as to why the Flow ID should be moved to this spec instead as @skissane suggests.\r\n\r\nEvery single application that utilizes DATAGRAM must decide if it wants to support being \"co-located\" with others, and if it does it will more-than-likely be with HTTP/3 and use the Flow IDs specified there.  That may be sufficient to keep from there being incompatible approaches, but the more we can do to minimize diverging implementations the better IMO.\r\n\r\nBy adding it as an OPTIONAL section to this spec instead gives it increased visibility for implementers.  It doesn't restrict those that definitely do not need to make use of it, but it does provide a strong reference point for those that do and is relevant to their non-HTTP/3 applications.\r\n\r\nThere seems to be some consensus in this thread that such a compromise is acceptable?\r\n",
          "createdAt": "2021-02-26T21:25:19Z",
          "updatedAt": "2021-02-26T21:25:19Z"
        },
        {
          "author": "vrubleg",
          "authorAssociation": "NONE",
          "body": "I was quite surprised that this spec doesn't specify a mandatory flow ID field. It is inconsistent with the main QUIC spec where having a lot of different flows through one QUIC connection is one of the main features.\r\n\r\nI think that the flow ID must be a mandatory field in this spec, to make all the QUIC based protocols extensible by default, just to let people to mux a few different QUIC based protocols into one QUIC connection easier.",
          "createdAt": "2021-02-27T07:20:02Z",
          "updatedAt": "2021-02-27T08:49:39Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I'm still happy with having no flow ID in the frame. I've not heard a strong concrete case where the wire format needs this information.\r\n\r\nI'd like to circle back to the points on priority. QUIC is purposefully quiet on the point of signalling stream priority, this is something that every application mapping will have to reinvent, and we are happy with that design decision. Many potential clients for a feature doesn't mean we need to provide it.",
          "createdAt": "2021-02-27T11:00:37Z",
          "updatedAt": "2021-02-27T11:00:37Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "I tried to put together a list of all the scenarios that I think would make use of unreliable data delivery. I came up with the following:\r\n\r\n- VPN/tunneling\r\n- Audio/video streaming\r\n- Gaming\r\n- App-layer keep alives\r\n- Status updates (e.g. latest temp reading)\r\n\r\nFor every one of these scenarios I can imagine some level of multiplexing being used. For that reason, I personally think QUIC should provide the (optional) multiplexing functionality natively and **not** require the application layers to continually reinvent the wheel.\r\n\r\nTo @LPardue's comparison to priorities, I disagree with the analogy. I don't think that all QUIC-based application protocols actually need priorities, and even few need to explicitly signal them to the peer; so keeping priority signals out of the QUIC layer makes sense. In contrast, multiplexing (whether over streams or datagrams) is a **core** functionality for QUIC, and I strongly believe that should extend to unreliable data delivery.\r\n\r\nSo, since most application protocols would use it (IMO), we should include (as an option) a flow ID in datagrams to support multiplexing.",
          "createdAt": "2021-02-27T17:33:09Z",
          "updatedAt": "2021-02-27T17:33:09Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I agree there are application use cases that can benefit from different logical flows. But the question that is at hand is, what services does the transport provide to those flows. There has to be a reason that it exists there. Do you want flow concurrency limits, do you want per-flow buffering etc\r\n\r\nOf the adopted work I am aware of in the IETF, to make multiplexing actually work, you need an application-layer signalling mechanism. This has been achieved using HTTP/3, to suit how HTTP uses QUIC. Are the needs of other application types similar?I think a lot of the work people anticipate needs doing can't be commonly solved; we risk tying up progress on DATAGRAM by designing an abstraction for loose requirements. ",
          "createdAt": "2021-02-27T17:54:01Z",
          "updatedAt": "2021-02-27T17:54:27Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "I agree there are different ways to possibly treat/view multiplexed unreliable delivery. On one extreme it is a fire and forget flow identifier and (unfragmented) byte blob; At the other extremely you have \"streams\" with unreliable delivery, and everything that goes with it (flow ID FC; per-flow FC; fragmentation/reassembly?). I **do not** think the datagram extension should encompass unreliable \"streams\". That is a far more complicated topic and should be left to it's own extension.\r\n\r\nI do believe this extension should encompass the first scenario. Just allow for an optional flow ID. As far as on the wire efficiency, it's cheapest to do it at the QUIC layer. We just use a separate code point for datagrams with flow ID and those without (as we had originally, right?). For the application layer to implement such optional behavior would require more space.\r\n\r\nPerhaps another way to look at i:. If enough people feel strongly about wanting this, but we can't get agreement here, would you really prefer a completely different extension (and associated draft) just to duplicate what's here but adds the flow ID? IMO, that seems like overkill. Worst case, I'd prefer to have two separate TPs in this draft to indicate support/negotiation for the two different types of datagram frames.",
          "createdAt": "2021-02-27T18:06:52Z",
          "updatedAt": "2021-02-27T18:19:26Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Nick, this is a good spectrum of options / requirements. Thanks for pulling on this thread. \r\n\r\nFor the record, this is my individual opinion based on my own individual implementation experience. I feel DATAGRAM is close to done and revisiting a core design decision at a late stage is unfortunate. But if its the right thing to do then it pays to really probe this and make a decision we can agree to never revisit. \r\n\r\nI don't know if everyone would agree with your pick on the spectrum. Establishing consensus on what a transport Flow ID should provide is important.\r\n\r\nJust adding a varint to the payload of the current DATAGRAM frame is easy. An application mapping can copy the blueprint of HTTP/3 DATAGRAM. \r\n\r\nI will highlight that providing more options adds some complexity to application mappings. You'll be asking them to have to decide if they want to use a flow ID or not. For example, iff a flow-ID containing transport frame were added, then H3 DATAGRAM needs to be updated to prohibit 2 of the frame types; or MASQUE need to be updated to do the same.\r\n\r\nOn balance, I think the pros/cons of the current design are evenly balanced with the alternative (plus its knock on effects).",
          "createdAt": "2021-02-27T18:26:47Z",
          "updatedAt": "2021-02-27T18:27:37Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "One option is to define a new frame (`MULTIPLEXED_DATAGRAM`?) and associated TP, and just keep it logically separate from the `DATAGRAM` frame and TP. HTTP/3 could continue to only use the `DATAGRAM` frame/functionality, and H3/QUIC implementations could get away with not ever supporting the multiplexed variant. If we went with that approach, would you prefer a completely separate draft for that? IMO, that would entail a lot of duplication of the non-framing specific text.",
          "createdAt": "2021-02-27T18:32:47Z",
          "updatedAt": "2021-02-27T18:33:07Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I think that because there is so much overlap between the two types that, whether they are in one document or two, aapplication mappings and implementers would face the same challenge either way.\r\n\r\nSo, personally, I remain to be convinced that such a design is needed. But if there is consensus to do so, a single document for both - that covers the tradeoffs - is a better way to spec it.",
          "createdAt": "2021-02-27T18:41:14Z",
          "updatedAt": "2021-02-27T18:41:42Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "Makes sense. A lot of this just comes down to folks' personal opinions. As the owner of a generic QUIC stack (and not any HTTP specific code) I prefer to support it at the QUIC layer, where we already have all the multiplexing abstraction code. I also really like the \"implement once\" property as well. IMO it generally leads to a cleaner API design and fewer bugs overall.\r\n\r\nOne final data point: I have had discussion with teams at Microsoft that have non-HTTP based protocols that are looking to move to QUIC, and I do believe they would benefit from native multiplexed unreliable delivery support in QUIC. Obviously they (and any protocol) can do it themselves, but it doesn't mean they should.",
          "createdAt": "2021-02-27T18:49:16Z",
          "updatedAt": "2021-02-27T18:49:16Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Understood. As a maintainer of a generic QUIC stack I want to know if the only service people want from me is basically variable-integer flow ID handling or if they want more.  I can expose varint handling helper functions but more complicated things are harder.",
          "createdAt": "2021-02-27T19:07:59Z",
          "updatedAt": "2021-02-27T19:07:59Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "body": "As someone working on multiple applications that use DATAGRAM but not H3, I want to ensure that they all can be composed together on one connection compatibly and easily.\r\n\r\nIf I implement the Flow portion of the H3 DATAGRAM independently in each application then I will also have to implement my own shim layer to manage the Flow IDs compatibly when the underlying QUIC library doesn't provide it, and hope that H3-supporting libraries also expose compatible APIs for multiplexing with HTTP.\r\n\r\nNone of that is very difficult really, but it seems that a likely byproduct is pressure on DATAGRAM supporting QUIC libraries to provide the Flow ID counters in a central place independent from any H3 support.\r\n\r\nI'm not suggesting that it must be added here, but a clear (if small) specification of Flow IDs separate from the H3 DATAGRAM spec could really aid in ensuring compatible implementations and application APIs for all QUIC DATAGRAM libraries that intend to support multiple applications over one connection.",
          "createdAt": "2021-02-27T22:14:12Z",
          "updatedAt": "2021-02-27T22:14:12Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Multiplexing different application mappings inside a single QUIC connection has a bunch of complexity not confidend to DATAGRAM. For instance, QUIC provides stream IDs but the way that H3 chooses to use them means that it can't be multiplexed with other applications without some form of shim. MASQUE is one such shim, which links flow ID allocation to HTTP signalling. There's other ways to do it this of course.\r\n\r\nIt sounds like @quartzjer is asking for something similar to QUICs Stream ID management. This covers (among other things) stream ID allocation and enforcement of stream ID usage, which is a transport interoperability feature. To do the same for DATAGRAM flow IDs would require additional signalling like \"max_initial_flowd\" TP, and MAX_FLOWS frame. This might be something people want but I don't really know. However, even if a connection-wide transport flow ID manager existed then, just like with stream IDs, there would still be competition between application protocols that want to multiplex themselves together in the shared flow ID space. The hard problem would remain unsolved.\r\n\r\nThe difficulties with sharing stream ID and flow ID space is already manifest in the WebTransport group. Demonstrating that even pooling together multiple instances of the same application mapping has challenges. ",
          "createdAt": "2021-02-28T01:04:27Z",
          "updatedAt": "2021-02-28T01:05:29Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "NONE",
          "body": "With an individual hat on - I agree with @LPardue on pretty much all of his points. There's definitely advantages to having a flow id at the transport, and it seems pretty straightforward at first glance. That being said there's a lot of complexity with actually managing those flow ids in a generic way. Once we put them in the transport we also have to be in the business of managing those flow ids. I agree that many applications will want to have some sort of flow id -- but I can also foresee those applications being rather opinionated about how those flow ids should behave, and I'd rather not have the transport try to meet those requirements in the generic extension.",
          "createdAt": "2021-03-01T22:24:26Z",
          "updatedAt": "2021-03-01T22:24:26Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "body": "I am better appreciating the complexity of adding even an optional basic transport-managed Flow ID, I'd rather see DATAGRAM be a simple standard as-is.\r\n\r\nIf there's consensus, the simplest resolution to this issue might be to just take the paragraph mentioning HTTP/3's flow identifier and make it a ## section to draw more attention to it for application and transport implementers to consider.  Possibly even expanding the text to highlight the choice applications will have to make if they want to share a connection with other DATAGRAM apps.",
          "createdAt": "2021-03-02T06:45:26Z",
          "updatedAt": "2021-03-02T06:45:26Z"
        },
        {
          "author": "ekinnear",
          "authorAssociation": "NONE",
          "body": "Discussed at IETF 110: Conversation in the room proposed that we point to H3 datagram as an example of what upper layers can do and indicate that other ALPNs should add something similar. Still didn't belong in the QUIC datagram itself, and if we find that many ALPNs repeat a pattern, they can share another extension / definition document.",
          "createdAt": "2021-03-10T12:59:50Z",
          "updatedAt": "2021-03-10T12:59:50Z"
        },
        {
          "author": "skissane",
          "authorAssociation": "NONE",
          "body": "I think it would be great if the text of the spec could include some brief rationale explaining the reasons for the decision reached. I think it would be helpful for readers to give some brief explanation of why the spec is the way it is on this topic, instead of having to dig through PRs / mailing list archives / etc in order to discover that.",
          "createdAt": "2021-03-11T02:27:12Z",
          "updatedAt": "2021-03-11T02:27:12Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Personally, I think an effective way of framing the rationale that @skissane is seeking is a direct comparison to streams (as set out in transport section 2 and 3). Datagram is another application-data carrying primitive, highlighting the core differences could help avoid people needing to ask these questions when they puzzle about how to write application mappings. The suggestion that Eric made would be a piece of such framing.",
          "createdAt": "2021-03-11T03:24:39Z",
          "updatedAt": "2021-03-11T03:24:39Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "MDU6SXNzdWU2MTQxNzgwNDU=",
      "title": "Is max_datagram_frame_size Unidirectional Configuration?",
      "url": "https://github.com/quicwg/datagram/issues/7",
      "state": "CLOSED",
      "author": "nibanks",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The spec clearly states the following:\r\n\r\n> The max_datagram_frame_size transport parameter is an integer value (represented as a variable-length integer) that represents the maximum size of a DATAGRAM frame (including the frame type, length, and payload) the endpoint is willing to receive, in bytes.\r\n\r\nBut it's not completely clear what happens if both sides send different values. Is the value purely a unidirectional configuration? For instance, if the server advertises a value of 500, and the client advertises a value of 100, can the client still send 500 byte datagrams? Or does this essentially negotiate the max value either side can use to 100?\r\n\r\nIf this is a unidirectional configuration, why require the peer to send the TP at all, if all they want to do is send datagrams, and not receive them? I'm loosely basing my thoughts on what the design could be on how we negotiate the number of streams an endpoint is willing to accept. Following that model, I'd recommend a design where, if an endpoint is willing to receive datagrams, it advertises a `max_datagram_frame_size` it's willing to accept. The TP has absolutely no meaning for the send direction. The protocol on top of QUIC decides how to interpret only a single direction allowing datagrams to be sent.",
      "createdAt": "2020-05-07T16:12:11Z",
      "updatedAt": "2020-05-08T22:32:04Z",
      "closedAt": "2020-05-08T22:32:04Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I agree with @nibanks, principly due to this clause in the present draft:\r\n\r\n```\r\nEndpoints MUST NOT send DATAGRAM frames until they have sent and received the max_datagram_frame_size transport parameter.\r\n```\r\n\r\nMy read of the current text is that it is unidirectional. An endpoint tells it's peer that it is willing to receive a DATAGRAM up to size N by using `max_datagram_frame_size`. Having asymmetric values is fine because the paths can be asymmetric and other TPs also behave asymmetrically.\r\n\r\nThe draft also says:\r\n\r\n```\r\nApplication protocols that use datagrams MUST define how they react to the max_datagram_frame_size transport parameter being missing.\r\n```\r\n\r\nFor an application protocol like siduck, both ends need to support reception of DATAGRAM or else the application will fail. For something like an IoT sensor feed, it might be fine to support a send-only/receive-only model. The current text basically requires the application protocol to mandate that `max_datagram_frame_size` is 0 on the side that is send-only AND to describe what happens if the TP is missing - that seems like it will cause a duplication of effort.\r\n\r\n",
          "createdAt": "2020-05-07T17:13:36Z",
          "updatedAt": "2020-05-07T17:13:36Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that we should make this purely unidirectional. I would resolve this by replacing\r\n\r\n`Endpoints MUST NOT send DATAGRAM frames until they have sent and received the max_datagram_frame_size transport parameter.`\r\n\r\nwith\r\n\r\n`Endpoints MUST NOT send DATAGRAM frames until they have received the max_datagram_frame_size transport parameter.`",
          "createdAt": "2020-05-08T01:19:48Z",
          "updatedAt": "2020-05-08T01:19:48Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "MDU6SXNzdWU2MTQxODYyNzk=",
      "title": "Text on Datagram's Interaction with Loss Recovery is a bit Light",
      "url": "https://github.com/quicwg/datagram/issues/8",
      "state": "CLOSED",
      "author": "nibanks",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The draft has some good text in the \"Acknowledgement Handling\" and \"Congestion Control\" sections that essentially is stating that DATAGRAM is just like any other ACK-eliciting packet, but is not automatically retransmitted by the transport. That's all reasonable, but I think there needs to be more text on how the (suspected) loss of a packet with a DATAGRAM frame or a PTO with only an outstanding DATAGRAM packet should be handled.\r\n\r\nI can see two possible models:\r\n\r\n1. It's just like any other packet. The goal is to elicit some ACK from the peer to get accurate loss information about the outstanding packet as soon as possible. If there is nothing outstanding we could use to send in a new packet, just send a PING frame.\r\n\r\n2. It's special. Because we don't necessarily intend to retransmit the data in the packet if it is actually lost, we don't actually care about immediate loss information/feedback. Don't force anything to be sent immediately to elicit the ACK.\r\n\r\nSo far as I have it coded up in MsQuic, I've assumed (1). This essentially results in an immediate PING frame/packet being sent out if I have nothing else to retransmit to try to elicit an ACK for the DATAGRAM frame/packet. This could result in a slightly noisier connection if the app doesn't care about all loss information about their datagrams, but, IMO makes for a cleaner design. I don't know what the general consequences to congestion control might be if we don't do this.\r\n\r\nAssuming folks are in agreement, we should have some text on this topic in the draft.",
      "createdAt": "2020-05-07T16:25:06Z",
      "updatedAt": "2021-07-12T17:59:28Z",
      "closedAt": "2021-07-12T17:59:28Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ianswett @janaiyengar as authors of the recovery draft do you have an opinion here?",
          "createdAt": "2020-05-08T01:15:43Z",
          "updatedAt": "2020-05-08T01:15:43Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "NONE",
          "body": "I support @nibanks choice of 1 and it aligns with the recovery draft.  It also matches our implementation. \r\n\r\nAdding clarifying text around this SG and I'd be happy to review it.",
          "createdAt": "2020-05-08T17:19:21Z",
          "updatedAt": "2020-05-08T17:19:21Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "NONE",
          "body": "I agree -- choice (1) is cleanest and I would argue that choice(2) is really not principled.",
          "createdAt": "2020-05-14T06:23:17Z",
          "updatedAt": "2020-05-14T06:23:17Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "body": "Late to the issue, but I think (1) is the right choice here.  It's not simply that datagrams aren't retransmitted, but that they _might_ be retransmitted by the application if they're declared lost.  If you don't have prompt feedback, that scenario suffers.",
          "createdAt": "2020-11-16T11:07:55Z",
          "updatedAt": "2020-11-16T11:07:55Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Seems like we have good agreement on this, just need to write the text",
          "createdAt": "2021-03-03T23:35:09Z",
          "updatedAt": "2021-03-03T23:35:09Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "NONE",
          "body": "@tfpauly -- To @ianswett 's comment at the mic, you should cite [Section 6.2.4 in the recovery draft](https://quicwg.org/base-drafts/draft-ietf-quic-recovery.html#section-6.2.4).",
          "createdAt": "2021-03-10T12:51:46Z",
          "updatedAt": "2021-03-10T12:51:46Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "MDU6SXNzdWU2MTQyMDY5NjI=",
      "title": "Nit picking error condition for supported but not enabled",
      "url": "https://github.com/quicwg/datagram/issues/9",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Sorry/not sorry for being pernickety. The current draft says:\r\n\r\n```\r\nAn endpoint that includes this parameter supports the DATAGRAM frame types and is willing to receive such frames on this connection.\r\n```\r\n\r\nand\r\n\r\n```\r\nAn endpoint that receives a DATAGRAM frame when it has not sent the max_datagram_frame_size transport parameter MUST terminate the connection with error PROTOCOL_VIOLATION.\r\n```\r\n\r\nwhich is slightly ambiguous if we consider an vanilla QUIC endpoint that does not implement this extension at all. Absence of the TP can indicate the parameter is totally unsupported, or is supported but is not desired for the current connection.  In the totally unsupported case, the receiving endpoint is likely to act according to transport Section 12.4 which says\r\n\r\n```\r\nAn endpoint MUST treat the receipt of a frame of unknown type as a\r\nconnection error of type FRAME_ENCODING_ERROR.\r\n```\r\n\r\nMaybe this doesn't need to be fixed because one shouldn't expect the requirements of an extension to apply if it is not implemented. But perhaps some editorial tweaks could tighten things up.\r\n\r\nFor the case of an endpoint does support DATAGRAM. You might also want to consider a wire message that more clearly describes the error condition of \"extension supported but not enabled\". This could be a new error code, or a reason phrase.\r\n",
      "createdAt": "2020-05-07T16:59:19Z",
      "updatedAt": "2020-05-08T01:45:36Z",
      "closedAt": "2020-05-08T01:45:36Z",
      "comments": [
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "It does seem to make sense to just to follow the guidance from the transport draft and use `FRAME_ENCODING_ERROR`. If folks want to add a reason phrase too, feel free, but that seems to be a implementation decision to me.",
          "createdAt": "2020-05-07T17:15:52Z",
          "updatedAt": "2020-05-07T17:15:52Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "The problem with reusing `FRAME_ENCODING_ERROR` is then it is completely ambiguous if the endpoint supports the extension but didn't enable it, or the endpoint doesn't support the extension at all. To me there is value in using different error codes for those conditions (we can't rely on endpoints populating or recording the reason phrase, as you say). The issue with `PROTOCOL_ERROR` is that it is different to `FRAME_ENCODING_ERROR` but is also the catch all bucket.",
          "createdAt": "2020-05-07T17:21:42Z",
          "updatedAt": "2020-05-07T17:21:42Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure I understand this issue. If a QUIC implementation does not support this specification, it is not bound by any of the requirements in this specification. So it'll happily use `FRAME_ENCODING_ERROR`.\r\n\r\nThis specification defines an extension to QUIC, and it can supersede any normative text in the QUIC specs. Therefore, if an implementation supports this extension, then it'll send `PROTOCOL_VIOLATION`.\r\n\r\nI don't see any ambiguity here.",
          "createdAt": "2020-05-08T01:23:32Z",
          "updatedAt": "2020-05-08T01:23:32Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I still see it but I think it all degenerates to \"we can't protect against stupid\" and that a more specific error code likely won't help a dumb client that sends DATAGRAMs in spite of not receiving the required TP. The strong signal of connection close is probably good enough, so let's close this and revisit if interop so reveals it to be useful.",
          "createdAt": "2020-05-08T01:45:35Z",
          "updatedAt": "2020-05-08T01:45:35Z"
        }
      ]
    },
    {
      "number": 12,
      "id": "MDU6SXNzdWU2NDI1MjgxNjk=",
      "title": "Question about scope: why only unreliable datagrams? Why not reliable datagrams too?",
      "url": "https://github.com/quicwg/datagram/issues/12",
      "state": "CLOSED",
      "author": "skissane",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Some applications might want to send messages, and not care about the order of delivery, but still get reliability.\r\n\r\nQUIC streams give them reliability, but within a stream it enforces order of delivery.\r\n\r\nThis datagram proposal gives unordered delivery of messages, but without reliability.\r\n\r\nWhy not provide datagrams with optional (opt-in) reliability?\r\n\r\nIt shouldn't be a lot of extra work for QUIC implementors to provide reliable datagrams as well as unreliable, given that retransmission is already there for QUIC streams.\r\n\r\n(I guess an application could create a separate QUIC stream for each unordered reliable message. That might work, but seems ugly and may have some overhead.)",
      "createdAt": "2020-06-21T09:25:00Z",
      "updatedAt": "2021-07-21T15:42:56Z",
      "closedAt": "2021-07-21T15:42:56Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What you describe can already be accomplished using streams: each \u201creliable datagram\u201d is its own stream. That provides reliable delivery without ordering between independent datagrams. I don\u2019t think we need to add optional reliability to the datagram spec.",
          "createdAt": "2020-06-21T17:34:33Z",
          "updatedAt": "2020-06-21T17:34:33Z"
        },
        {
          "author": "Ralith",
          "authorAssociation": "NONE",
          "body": "> I guess an application could create a separate QUIC stream for each unordered reliable message. That might work, but seems ugly and may have some overhead\r\n\r\nStreams are very lightweight, and well suited to this task. Beware applying intuition from TCP too heavily.",
          "createdAt": "2020-06-21T18:11:25Z",
          "updatedAt": "2020-06-21T18:11:25Z"
        },
        {
          "author": "skissane",
          "authorAssociation": "NONE",
          "body": "So, here's a suggestion then: since I'm sure I'm not the only person who is going to think of this, maybe add some verbiage to the spec explaining why supporting reliable datagrams is unnecessary?",
          "createdAt": "2020-06-22T00:04:39Z",
          "updatedAt": "2020-06-22T00:04:39Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sounds good. We can keep this issue open as requesting an editorial change.",
          "createdAt": "2020-06-22T00:52:46Z",
          "updatedAt": "2020-06-22T00:52:46Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "MDU6SXNzdWU3NDE5NzUxMjQ=",
      "title": "Why is the recommended `max_datagram_frame_size` 65536?",
      "url": "https://github.com/quicwg/datagram/issues/13",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Current text says:\r\n\r\n> It is RECOMMENDED to send the value 65536 in the max_datagram_frame_size transport parameter as that indicates to the peer that this endpoint will accept any DATAGRAM frame that fits inside a QUIC packet.\r\n\r\nThis is nice, but I'm wondering if it should be 65535. The max UDP payload for a QUIC packet is 65527, which is lower than both. It's nice for an implementation to only need to store 16-bit integers for max datagram size to avoid excess memory, and it's of course easy to round down from 65536 to 65535, but it just seems arbitrary to have it be 1 more than the max value for a 16-bit integer...",
      "createdAt": "2020-11-12T22:31:19Z",
      "updatedAt": "2020-11-13T03:32:20Z",
      "closedAt": "2020-11-13T03:32:20Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@DavidSchinazi  thoughts?",
          "createdAt": "2020-11-12T22:31:31Z",
          "updatedAt": "2020-11-12T22:31:31Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That sounds reasonable, 65535 is fine by me. (as long as the 1s don't take longer to travel than the 0s \ud83e\udd23)",
          "createdAt": "2020-11-12T22:39:15Z",
          "updatedAt": "2020-11-12T22:39:15Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "MDU6SXNzdWU3NDM3NTQzNzU=",
      "title": "Exposing datagram acknowledgements",
      "url": "https://github.com/quicwg/datagram/issues/15",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "An issue came up in discussions around WebTransport: https://github.com/w3c/webtransport/issues/168\r\n\r\nThe problem is that datagram frames may be acknowledged for the sake of congestion control, but dropped for the sake of flow control. \r\n\r\nA receiver with a full datagram buffer would have two choices:\r\n1. Drop any packets with datagram frames and do not acknowledge them.\r\n2. Drop the datagram frames but acknowledge the packets.\r\n\r\nThe first approach seems terrible because it drop any other frames bundled with the datagram (ex. STREAM) and cause retransmissions. It would also be treated as network congestion by the sender, causing limited bandwidth for otherwise unrelated STREAM frames.\r\n\r\nThe second approach has ramifications for any implementations that MAY expose datagram acknowledgements. Specifically, the sender would believe that the datagram has been received (although not necessary processed), when in reality it could have been dropped and will never be processed.",
      "createdAt": "2020-11-16T11:21:33Z",
      "updatedAt": "2021-07-12T17:53:47Z",
      "closedAt": "2021-07-12T17:53:47Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "NONE",
          "body": "I suggest that we remove the recommendation that datagram acknowledgements can be exposed to the application, and possibly even prohibit it.",
          "createdAt": "2020-11-16T11:23:45Z",
          "updatedAt": "2020-11-16T11:23:45Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "NONE",
          "body": "Alternatively, this problem could be avoided if there was explicit flow control for datagrams. This would avoid a full datagram buffer and may have other benefits.",
          "createdAt": "2020-11-16T11:26:17Z",
          "updatedAt": "2020-11-16T11:26:17Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Adding flow control to DATAGRAM seems like a problem for use cases that don't want that, like tunneling of UDP-based transports that provide their own flow control",
          "createdAt": "2020-11-16T12:04:18Z",
          "updatedAt": "2020-11-16T12:04:18Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "I may be wrong, but this seems very implementation specific, but IMO flow control is unnecessary so long as datagrams are indicated to the application layer inline (no buffering).\r\n\r\nFor instance, MsQuic only acknowledges a packet with a datagram frame if it's able to successfully process it (datagram frame processing [here](https://github.com/microsoft/msquic/blob/main/src/core/connection.c#L4411)). Additionally, \"processing\" a datagram frame **includes** indicating it up (inline indication [here](https://github.com/microsoft/msquic/blob/main/src/core/datagram.c#L575)) to the application layer. There is absolutely no buffering at the datagram frame layer in MsQuic; so flow control is not a really issue.\r\n\r\nIt's possible the application layer then does some buffering and would require flow control, but that's completely up to the application layer. If there is a scenario where the application layer may drop data (due to buffering constraints or something else) it should be up to the application layer to decide if the peer needs to know that information; and if so, inform them appropriately at their layer.",
          "createdAt": "2020-11-16T18:06:25Z",
          "updatedAt": "2020-11-16T18:06:25Z"
        },
        {
          "author": "Ralith",
          "authorAssociation": "NONE",
          "body": "> Adding flow control to DATAGRAM seems like a problem for use cases that don't want that\r\n\r\nSurely that could be addressed by specifying arbitrarily large or infinite flow control limits? Would still complicate the spec, which seems unfortunate.\r\n\r\n> IMO flow control is unnecessary so long as datagrams are indicated to the application layer inline\r\n\r\nThat's a really cool solution. It's not a small constraint on the receiver's implementation, but it's certainly a case where we forbidding application-visible ACKs would be a harmful restriction.",
          "createdAt": "2020-11-16T18:37:22Z",
          "updatedAt": "2020-11-16T18:37:22Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "NONE",
          "body": "Inline datagram processing is a cool idea and removes the need for flow control.\r\n\r\nUnfortunately, it's the sender that exposes acknowledgements to the application, but it's the receiver that would need to process and acknowledge datagrams inline. The sender would not be able to assume the receiver uses a particular implementation.",
          "createdAt": "2020-11-16T18:49:39Z",
          "updatedAt": "2020-11-16T18:49:39Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "The capability to do inline indications on the receive side could be negotiated with the transport parameter. \"Hey, I receive datagrams, **and** I don't buffer them.\" Then the sender side can decide how they want to handle ACKs based on that state. Though, it's not great that they still have to handle the scenario of \"I do buffer, and I might throw them away\" so long as any peer they communicate with might buffer.\r\n\r\nPersonally, I'd just like to say that we require guaranteed app delivery for acknowledged QUIC packets with datagram frames, and then let QUIC implementations sort it out, but I realize that's not easily done for most implementations without significant refactoring. But if we don't do this, I do see it as a **major bummer** that buffering on the receiver side could effectively make QUIC layer acknowledgements worthless to the app (which IMO was the best advantage to this solution).",
          "createdAt": "2020-11-16T18:55:23Z",
          "updatedAt": "2020-11-16T18:55:40Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "My only other thought would be to have a new frame (e.g. DATAGRAM_DROPPED) that a receiver sends if it drops DATAGRAM frame; but to accurately identify which that were dropped, each datagram would need a unique identifier and that further complicates all this. So I definitely wouldn't prefer this solution.",
          "createdAt": "2020-11-16T19:00:44Z",
          "updatedAt": "2020-11-16T19:00:44Z"
        },
        {
          "author": "Ralith",
          "authorAssociation": "NONE",
          "body": "> \"Hey, I receive datagrams, and I don't buffer them.\"\r\n\r\nOr, in more explicit terms, \"My ACKs guarantee delivery of datagram frames to the application.\"\r\n\r\n> it's not great that they still have to handle the scenario of \"I do buffer, and I might throw them away\"\r\n\r\nIs this any different from handling the scenario of a peer that doesn't support datagram frames at all?",
          "createdAt": "2020-11-16T19:45:59Z",
          "updatedAt": "2020-11-16T19:45:59Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with @nibanks's earlier comment that this sounds very implementation-specific. Our implementation also would not drop any datagram frames that have been received and ack'ed, since we process the data immediately and send it inline.\r\n\r\nI'd almost prefer to just have a SHOULD NOT drop datagram frames if they've been received and ack'ed. This will certainly influence API design, and means that you'll have a rougher time if you just try to imitate a UDP socket buffer.",
          "createdAt": "2020-11-16T20:05:38Z",
          "updatedAt": "2020-11-16T20:05:38Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "> Is this any different from handling the scenario of a peer that doesn't support datagram frames at all?\r\n\r\nYes, there is a difference. If the peer doesn't support datagram frames at all, the protocol might not work at all, and the app layer will just reject the connection outright. If the app supports datagram frames, but it's implementation may or may not buffer. In that case, depending on the app protocol, it may or may not then need additional app layer acknowledgements or accounting.\r\n\r\nFor instance, perhaps some game protocol that has a fire-and-forget \"current player state\" datagram payload could care less about acknowledgements, so it doesn't care if buffering drops a frame. All it needs is datagram support.",
          "createdAt": "2020-11-16T20:05:50Z",
          "updatedAt": "2020-11-16T20:06:33Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "> I'd almost prefer to just have a SHOULD NOT drop datagram frames if they've been received and ack'ed. This will certainly influence API design, and means that you'll have a rougher time if you just try to imitate a UDP socket buffer.\r\n\r\nI would also prefer this approach.",
          "createdAt": "2020-11-16T20:08:32Z",
          "updatedAt": "2020-11-16T20:08:32Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "For an implementation that doesn't expose the contents of QUIC packets to an application, exposing the ACKs has little value. The flow control issue is then a little moot. I would push back on any strict requirements as mentioned, it presupposes that implementations will provide a single style of processing or API.\r\n\r\nSHOULD NOT seems acceptable because I _would_ drop them based on some criteria and the text probably encourages me to document this aspect.",
          "createdAt": "2020-11-16T20:30:36Z",
          "updatedAt": "2020-11-16T20:30:36Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "NONE",
          "body": "In the context of WebTransport, datagrams are processed at the Javascript level. Browsers are understandably not going to execute and block on inline Javascript callbacks for every received datagram. ",
          "createdAt": "2020-11-16T20:40:45Z",
          "updatedAt": "2020-11-16T20:40:45Z"
        },
        {
          "author": "Ralith",
          "authorAssociation": "NONE",
          "body": "> If the app supports datagram frames, but it's implementation may or may not buffer. In that case, depending on the app protocol, it may or may not then need additional app layer acknowledgements or accounting.\r\n\r\nWhy can't the app layer reject the connection outright if the peer's transport parameters indicate that it does not support reliable acknowledgement for datagrams, just as it would if they indicate no support for datagrams at all? An app which doesn't care about ACKs obviously wouldn't do so, but those that do, can. Or they could apply app-layer mitigations, but that's more options, not fewer.",
          "createdAt": "2020-11-16T21:04:01Z",
          "updatedAt": "2020-11-16T21:05:06Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 to https://github.com/quicwg/datagram/issues/15#issuecomment-728315700 . There is a process hop between the QUIC code and the JavaScript code, and the QUIC code needs to send ACKs quickly (especially if that packet contains a STREAM frame next to a DATAGRAM frame) so it's simply not possible to wait on JavaScript before sending the ACK. You could buffer datagrams indefinitely after ACking them to ensure that the application gets them, but that goes against the entire philosophy of DATAGRAMs by increasing latency unboundedly. \"SHOULD NOT drop DATAGRAM frames\" sounds completely unrealistic to me.",
          "createdAt": "2020-11-16T21:05:15Z",
          "updatedAt": "2020-11-16T21:05:15Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "> For an implementation that doesn't expose the contents of QUIC packets to an application, exposing the ACKs has little value.\r\n\r\n@LPardue You don't need to expose how a datagram frame buffer from the app is put in a QUIC packet in order to give them information back about the receipt (or not) of an acknowledgement of their data. MsQuic allows the app to give a context pointer along with the buffer they send. We then indicate acknowledgement or suspected loss information back to the app for that context (event [here](https://github.com/microsoft/msquic/blob/main/src/inc/msquic.h#L811)).\r\n\r\n> Browsers are understandably not going to execute and block on inline Javascript callbacks for every received datagram.\r\n\r\n@kixelated and @DavidSchinazi I totally agree that it's unreasonable to expect every layer above QUIC in the WebTransport scenario to do inline delivery, but that isn't the only scenario, and having that one scenario's requirement for buffering shouldn't make us throw our hands up and say no scenarios will be able to use a zero buffering approach. Protocols directly on top of QUIC should be able to do whatever they want.\r\n\r\nThe \"SHOULD NOT drop DATAGRAM frames\" purely at the QUIC layer is not unrealistic IMO. What the layers on top of QUIC do are totally up to them to define and implement. WebTransport datagrams processed at the Javascript layer will need application layer acknowledgements if the protocol requires info on exactly which datagrams were delivered.",
          "createdAt": "2020-11-16T23:01:15Z",
          "updatedAt": "2020-11-16T23:01:15Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Thanks Nick, that makes more sense. I do wonder though how useful it acks are if you're talking to my endpoint who might, in some conditions, drop the occasional DATAGRAM on the floor.\r\n\r\n\r\n",
          "createdAt": "2020-11-16T23:54:53Z",
          "updatedAt": "2020-11-16T23:54:53Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@nibanks I was thinking of this in terms of WebTransport since that was really top of mind. I agree that different applications have different needs, and some might be able to do this inline ACKing more than others. That said, I'm really not sure what the point of this SHOULD NOT is, it's like saying \"an IP router SHOULD NOT drop IP packets\" - most router implementors know that they shouldn't drop packets unless they have a good reason such as having nowhere to put the packet.",
          "createdAt": "2020-11-17T01:14:12Z",
          "updatedAt": "2020-11-17T01:14:12Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "> it's like saying \"an IP router SHOULD NOT drop IP packets\" \r\n\r\n@DavidSchinazi I do agree somewhat with that sentiment, but it's a bit different because the transport is saying \"Yes, I got the packet and was able to successfully process it.\". If it's possible/allowable for the transport to then just drop it on the floor, is there really any reason to acknowledge datagram frames at all, beyond just another RTT estimate?\r\n\r\nI just feel it would be a big shame that we have all this ACK machinery built into QUIC, but it gets wasted on datagrams. Not only that, it has to be rebuilt completely by the app to duplicate all the work QUIC already does.",
          "createdAt": "2020-11-17T02:45:45Z",
          "updatedAt": "2020-11-17T02:45:45Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@nibanks the way I see it, there are only two ways to perform queueing when you have one input and one output:\r\n- option 1: you buffer things indefinitely forever\r\n- option 2: you don't\r\n\r\nI really don't see any other way. I think you're suggesting that transports should buffer DATAGRAMs infinitely if the application is busy, and that doesn't sound like a good idea to me.",
          "createdAt": "2020-11-17T05:35:20Z",
          "updatedAt": "2020-11-17T05:35:20Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "NONE",
          "body": "There are two questions here:\r\n- who owns the buffers -- QUIC, or the application; and\r\n- what are the application's reliability requirements.\r\n\r\nI would argue that for maximizing generality of a DATAGRAM receiver implementation -- so that multiple application behaviors are possible -- you want the application to own these buffers. Whether these buffers are implemented in QUIC or at the application or somewhere in between doesn't matter; it is meant for the application.\r\n\r\nFor an application that wants some notion of reliability, there are two choices in how a receiver manages its buffers:\r\n- it signals delivery out of the buffers and/or loss (ACKs/NACKs/gaps);\r\n- it signals buffer size explicitly to avoid any loss (flow control)\r\n\r\nAn app that sits on top of QUIC DATAGRAMs thus has two choices:\r\n- use explicit Application ACKs to signal receipt (and gaps or NACKs to signal loss), since the sender might have caused the application buffer to overflow;\r\n- use explicit flow control to disallow application buffer overflowing. Doing this has the nice property that QUIC ACKs can then be treated as application ACKs, since application flow control will ensure that this data does not get dropped at the receiver between QUIC and the app.\r\n\r\nIn either case, it's a decision that is both application- and implementation-dependent. An app that cannot know the buffer size will have to rely on using explicit application ACKs. An app that is ok with data loss can allow loss to happen, and may or may not signal this back. An app that wants to avoid buffer overflow at the application buffers can reuse QUIC ACKs as application ACKs but will need to ensure that application flow control is in place.\r\n\r\nImplementations ought to expose DATAGRAM QUIC ACKs to the application, so that applications have a choice of using that signal. However, the application is ultimately responsible for using them correctly.",
          "createdAt": "2020-11-19T05:54:30Z",
          "updatedAt": "2020-11-19T05:54:30Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "@janaiyengar the way I read your summary of the issue (which is great, btw. Thanks!) it seems that not only do ACKs need to be exposed to the application, but a receiver can't drop acknowledged datagrams without informing the application, right? Otherwise, how would the app be able to reliably implement it's own flow control along with QUIC ACKs? A sender who receives an ACK of a datagram would assume that datagram is taking up buffer on the peer application; but if QUIC dropped it before it received that buffer, then both application sides would get out of sync in their view of the FC window. The sender could eventually stall out because of this, right?",
          "createdAt": "2020-11-19T06:10:07Z",
          "updatedAt": "2020-11-19T06:10:07Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "NONE",
          "body": "\"Instant processing\" model is really nice, and makes sense if you're in the same process as the QUIC stack, but across a privilege separation boundary (web app/browser, userspace/kernel, etc), this is not feasible*, so I don't think this should be allowed at least by default.\r\n\r\n*&nbsp;this is technically possible, and it is in fact how WebSocket API works; if your web app is too slow at processing incoming WebSocket messages, your server will just crash a browser tab remotely by overflowing the task queue, so most people agree this was a big mistake.",
          "createdAt": "2021-01-22T05:44:16Z",
          "updatedAt": "2021-01-22T05:44:16Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "body": "After reading through this thread I may have missed it, but has anyone considered simply having the spec say something along the lines of:\r\n\r\n\"If an ACK frame has been sent and then due to implementation specific buffering or resource constraints it is unable to process the corresponding DATAGRAM frame, the application MUST be notified of the locally dropped frames so that it has the option to support additional signaling if necessary.\"\r\n\r\nThis will ensure that only for any implementation where this case is possible, the application developer/operator will be made aware of such a possibility and can decide how best to handle it either through configuration or custom application logic.\r\n",
          "createdAt": "2021-02-26T20:27:02Z",
          "updatedAt": "2021-02-26T20:27:02Z"
        },
        {
          "author": "Ralith",
          "authorAssociation": "NONE",
          "body": "What could a reasonable application do with that notification, aside from assert that it doesn't happen?",
          "createdAt": "2021-03-01T06:38:37Z",
          "updatedAt": "2021-03-01T06:38:37Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "body": "> What could a reasonable application do with that notification, aside from assert that it doesn't happen?\r\n\r\nMany things are possible with the notification, the ability to recognize when the dropped packets are not due to network congestion could be used to do custom throughput signaling back to the sender that incorporates other local signals such as queue depth or processing rate.  \r\n\r\nThe underlying implementation might also expose dynamic controls on the cache or queue size that the application can adjust.  It could also back off other memory or processor heavy operations in order to prioritize capacity to not drop future packets.\r\n\r\nBy ensuring that the ACK signaling only indicates congestion it isolates the responsibility of additional flow control signaling to just implementations that support it, only having to support notifying applications in such an event where frames are dropped locally.",
          "createdAt": "2021-03-01T07:23:53Z",
          "updatedAt": "2021-03-01T07:23:53Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "Dropping datagrams ought to be similar to resetting a stream. It is pretty much the same semantic.\r\n",
          "createdAt": "2021-03-10T12:59:12Z",
          "updatedAt": "2021-03-10T12:59:12Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@huitema can you elaborate? Resetting a stream is a non-recoverable situation for a stream, whereas dropping datagrams is recoverable.",
          "createdAt": "2021-03-10T13:37:19Z",
          "updatedAt": "2021-03-10T13:37:19Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "Resetting streams is defined as an application triggered message: application says it cannot proceed with the stream and provides an application defined code and reason. I think the application saying \"I am dropping some of the datagrams that I received\" has similar semantics.",
          "createdAt": "2021-03-10T13:47:46Z",
          "updatedAt": "2021-03-10T13:47:46Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I see. It would make me sad to turn a recoverable error into an unrecoverable one though, because some applications may not want that.",
          "createdAt": "2021-03-10T13:51:00Z",
          "updatedAt": "2021-03-10T13:51:00Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "Yes, that's where the analogy with reset breaks. The datagram dropped message should be informative, not change the state of the connection or the datagram streams.",
          "createdAt": "2021-03-10T13:52:27Z",
          "updatedAt": "2021-03-10T13:52:27Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "The difficulty I have with this concept is that I don't know what I'd expose to the application. My datagram implementation basically keeps a fixed-size queue of frames. So if I dropped some all I can tell an application is that something got dropped. Adding more information about what was dropped increases complexity.\r\n\r\nThe library already doesn't expose information about packets to the application, and so far things have worked out OK.",
          "createdAt": "2021-03-10T14:33:00Z",
          "updatedAt": "2021-03-10T19:32:50Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "I tend to agree that there isn't much a QUIC stack that queues datagrams can do here. The best it could do it indicate how many it dropped, but that's likely not enough. If that data needs to be retransmitted then (at the app layer) they would likely need more detailed info (such as an app identifier for each dropped packet).\r\n\r\nI think the best the draft can do here is mention that if the QUIC stack drops datagrams frames and also acknowledges them, then those acks cannot be leveraged by the application layer. It might be nice to have an additional TP that allows behavior this to be negotiated, but it's not strictly necessary.",
          "createdAt": "2021-03-10T14:50:23Z",
          "updatedAt": "2021-03-10T14:50:23Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "\" If that data needs to be retransmitted then (at the app layer) \" ... then the app needs to run a transport on top of datagrams. Or use regular streams.",
          "createdAt": "2021-03-10T16:15:16Z",
          "updatedAt": "2021-03-10T16:15:16Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1, if you need reliability then datagrams are not the droids you're looking for",
          "createdAt": "2021-03-10T19:30:50Z",
          "updatedAt": "2021-03-10T19:30:50Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "The more I think on this, the more it just seems similar to the existing notion that we have with QUIC streams; transport delivery != application end-to-end delivery & processing. It's like email read-reciepts: just because I opened the email doesn't mean I read it, digested it and have a response.\r\n\r\nThe doc might benefit from doing a better job of explaining this notion and the interop concerns that might arise. For instance, stating that it is possible for receiving implementations to acknowledge DATAGRAM-bearing packets while providing no guarantee that the DATAGRAMS are presented to the application. Valid reasons are flow control or any other arbitrary reason the receiver decides. Application's that desire end-to-end loss-detection need to be aware of this possibility and build measures that accomodate it. As Jana points out, there are some signals an implementation MAY chose to provide to make that easier. If they don't, applications can vote with their feet.",
          "createdAt": "2021-03-10T20:16:06Z",
          "updatedAt": "2021-03-10T20:16:06Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Adding text to clarify that receipt of an ACK for a packet containing a DATAGRAM frame does not mean that the application got the frame sounds like the right solution here.",
          "createdAt": "2021-03-10T20:24:54Z",
          "updatedAt": "2021-03-10T20:24:54Z"
        }
      ]
    },
    {
      "number": 16,
      "id": "MDU6SXNzdWU3OTE3MDgzMjU=",
      "title": "Document interaction of datagrams with pacing",
      "url": "https://github.com/quicwg/datagram/issues/16",
      "state": "CLOSED",
      "author": "vasilvv",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Early in our VPN implementation, we sent QUIC datagrams without any queueing, assuming that if a datagram gets dropped, then we exceeded the cwnd (and thus the estimated channel capacity), so it would likely not reach the peer anyways.  In practice, this turned out to be a terrible idea that lead to underutilization of the channel; our implementation always does pacing, so if you don't queue the datagram, it *will* get dropped unless it just happens to fit into the current pacing quantum.\r\n\r\nBecause pacing is RECOMMENDED for QUIC, I believe some form of queueing should be RECOMMENDED for datagrams, otherwise the users risk running into the same hard-to-debug problem that we had.",
      "createdAt": "2021-01-22T05:23:33Z",
      "updatedAt": "2021-03-04T18:12:11Z",
      "closedAt": "2021-03-04T18:12:11Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think adding a note about pacing to the \"Congestion Control\" subsection makes sense to me.",
          "createdAt": "2021-01-22T22:37:40Z",
          "updatedAt": "2021-01-22T22:37:40Z"
        },
        {
          "author": "ekinnear",
          "authorAssociation": "NONE",
          "body": "+1, if you're in the bucket of implementations that have insight into their pacing algorithm, it should be reasonable to expect that you'd avoid dropping your own datagrams unless you make a queue and then build up too much in that queue. ",
          "createdAt": "2021-01-22T22:48:43Z",
          "updatedAt": "2021-01-22T22:48:43Z"
        }
      ]
    },
    {
      "number": 24,
      "id": "MDU6SXNzdWU5NDcxODM1NTQ=",
      "title": "Can be acknowledged?",
      "url": "https://github.com/quicwg/datagram/issues/24",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "> QUIC datagrams, while unreliable, can support acknowledgements, allowing applications to be aware of whether a datagram was successfully received.\r\n-- https://www.ietf.org/archive/id/draft-ietf-quic-datagram-03.html#section-2-2.3\r\n\r\nIsn't it the case that they *are* acknowledged?\r\n\r\n(This one is just a nit, the next issue will be more serious.)",
      "createdAt": "2021-07-19T01:54:19Z",
      "updatedAt": "2021-07-19T20:23:29Z",
      "closedAt": "2021-07-19T20:23:29Z",
      "comments": []
    },
    {
      "number": 26,
      "id": "MDU6SXNzdWU5NDcxODc4MDA=",
      "title": "Overstating value of acknowledgments",
      "url": "https://github.com/quicwg/datagram/issues/26",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "> QUIC datagrams, while unreliable, can support acknowledgements, allowing applications to be aware of whether a datagram was successfully received.\r\n-- https://www.ietf.org/archive/id/draft-ietf-quic-datagram-03.html#section-2-2.3\r\n\r\nThis is not an application-layer signal.  While the peer might have received the packet and processed it at the QUIC layer, this does not guarantee that the DATAGRAM frame contents were processed by the application.\r\n\r\nThe draft already acknowledges this in [Section 5.2](https://www.ietf.org/archive/id/draft-ietf-quic-datagram-03.html#name-acknowledgement-handling).  However, the treatment in the motivation could be misleading.\r\n\r\nConsider dropping this item.",
      "createdAt": "2021-07-19T02:01:43Z",
      "updatedAt": "2021-07-19T20:23:29Z",
      "closedAt": "2021-07-19T20:23:29Z",
      "comments": []
    },
    {
      "number": 29,
      "id": "MDU6SXNzdWU5NDcyMDIzMDM=",
      "title": "Reiterate need for 0-RTT profile",
      "url": "https://github.com/quicwg/datagram/issues/29",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Application protocols that use QUIC are required to define how 0-RTT is used.  This draft doesn't really change that, but it does add to what 0-RTT can carry.  In an abundance of caution, it should link to [Section 5.6 of RFC 9001](https://quicwg.org/base-drafts/rfc9001.html#section-5.6-3).",
      "createdAt": "2021-07-19T02:30:27Z",
      "updatedAt": "2021-07-19T20:28:46Z",
      "closedAt": "2021-07-19T20:28:46Z",
      "comments": []
    },
    {
      "number": 32,
      "id": "MDU6SXNzdWU5NDcyMDg4OTk=",
      "title": "Awkward phrasing of pacing requirement",
      "url": "https://github.com/quicwg/datagram/issues/32",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "> Implementations that use packet pacing SHOULD support delaying the transmission of DATAGRAM frames for at least the time it takes to send the paced packets allowed by the congestion controller to avoid dropping frames excessively.\r\n\r\nI am having trouble parsing this.  I think that this is saying that if you have a pacer, then an endpoint might delay DATAGRAM frames to avoid overriding the sending rate of the pacer.\r\n\r\nHowever, this seems to imply that the maximum delay imposed here is the inter-packet interval of the pacer.  I think that is a bad assumption, even if it might be a simplifying assumption that some implementations might choose to adopt.  In some cases, the pacer interval will be too slow for the application (for low BDP, high RTT connections especially) or in some cases the pacer interval might be short enough to allow multiple intervals before dropping the packet (for high BDP, short RTT connections).\r\n\r\nThe goal should just be to avoid deferring DATAGRAM sending indefinitely, with controls over any delays being available to applications.\r\n\r\nMaybe:\r\n\r\n> Implementations that use packet pacing ({{Section 7.7 of RFC9002}}) can delay transmission of DATAGRAM frames to avoid having packets sent faster than pacing would otherwise allow.  Any transmission delays will need to allow for application-level constraints on frame delivery times.",
      "createdAt": "2021-07-19T02:51:01Z",
      "updatedAt": "2021-08-07T01:47:19Z",
      "closedAt": "2021-08-07T01:47:19Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think the goal here was to prevent implementations naively dropping DATAGRAM frames anytime they couldn't be sent immediately, which would be a pathologically bad case when a packet pacer is being used. But good point that this should be clarified.",
          "createdAt": "2021-07-19T23:29:52Z",
          "updatedAt": "2021-07-19T23:29:52Z"
        }
      ]
    },
    {
      "number": 33,
      "id": "MDU6SXNzdWU5NDgwMTE1NzU=",
      "title": "Update acknowledgements section to include WG contibutors",
      "url": "https://github.com/quicwg/datagram/issues/33",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "We should update the acknowledgements",
      "createdAt": "2021-07-19T20:43:36Z",
      "updatedAt": "2021-07-21T15:43:06Z",
      "closedAt": "2021-07-21T15:43:06Z",
      "comments": []
    },
    {
      "number": 35,
      "id": "MDU6SXNzdWU5NDg5MzgzNTk=",
      "title": "Lack of application-defined format",
      "url": "https://github.com/quicwg/datagram/issues/35",
      "state": "CLOSED",
      "author": "MikeBishop",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Neither this draft nor H3-Datagrams says what the behavior should be when the transport supports DATAGRAM frames but no supported application format has been negotiated for them.  While I think the correct behavior would be to drop them, since there's no ability to interpret their payload, no document actually says that.  There's also a legitimate argument for closing the connection, since something was sent that the application layer can't deal with.\r\n\r\nH3-Datagrams probably can't say that, since the possibility exists that a different datagram-payload format will be deployed for HTTP/3 in the future.  Should this document have a sentence about what happens when the application-layer doesn't define what to do with incoming datagrams / doesn't consume them?\r\n\r\n(There's also the question of simultaneously supporting two different formats, but I think that's an application-layer issue this document can ignore.)",
      "createdAt": "2021-07-20T18:40:20Z",
      "updatedAt": "2021-08-06T16:50:51Z",
      "closedAt": "2021-08-06T16:50:51Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Due to reordering, it's possible that a DATAGRAM frame arrives before the QUIC packet which negotiates the application format. Therefore we can't close the connection here. Depending on the application, it might be best to drop the datagram, or buffer it in hopes of later negotiating the format. I'm not sure draft-ietf-quic-datagram needs to say anything, what's wrong with leaving that up to applications?",
          "createdAt": "2021-07-20T18:45:18Z",
          "updatedAt": "2021-07-20T18:45:18Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "The corollary to Mike's question also applies, what happens if an application protocol doesn't use QUIC streams?\r\n\r\nGetting something written somewhere seems sensible, I suggest the applicability draft.",
          "createdAt": "2021-07-20T18:46:57Z",
          "updatedAt": "2021-07-20T18:46:57Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "body": "True, there's also an indeterminate state before you know what the application supports, for H3 at least.  But once you know what the application supports and behavior is different than expected, something needs to happen. Preferably there should be a spec that says what should happen; implementation guidance in applicability is an option as well.",
          "createdAt": "2021-07-20T20:17:13Z",
          "updatedAt": "2021-07-20T20:17:13Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think there's anything concrete the transport can say here, but we could point to the fact that the application needs to define it's behavior for datagrams.",
          "createdAt": "2021-07-20T21:13:24Z",
          "updatedAt": "2021-07-20T21:13:24Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sense of the room in 111 was that we should probably close this with no action.",
          "createdAt": "2021-07-27T19:29:28Z",
          "updatedAt": "2021-07-27T19:29:28Z"
        }
      ]
    },
    {
      "number": 41,
      "id": "MDU6SXNzdWU5NTM4NTQ5OTI=",
      "title": "Is it obvious that Datagram frame can be aggregated in the same QUIC packet",
      "url": "https://github.com/quicwg/datagram/issues/41",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I find no discussion about aggregating DATAGRAM frames in the same QUIC packets, with other DATAGRAM frames or other types. Is that so obvious that it is possible that it doesn't need mentioning?\r\n\r\nI would be slightly worried that an QUIC stack that aggregate may cause fate sharing between different datagram frames, which the application wasn't expecting. In a classical UDP application clearly doing two calls for UDP packets will create two different packets. Two calls to transmit Datagram frames may not cause multiple QUIC packets to be sent, which is usually for the good. However, it goes back to maybe be clear that this may occurr, and a question if API needs consideration to indicate if aggregation is fine or not?",
      "createdAt": "2021-07-27T12:56:58Z",
      "updatedAt": "2021-08-26T08:21:10Z",
      "closedAt": "2021-08-26T08:21:10Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We originally had text for this, but folks pointed out that we can't make recommendations that apply to all use cases: some might want fate sharing while some might not. It's probably best to leave this up to the application.",
          "createdAt": "2021-07-27T16:16:34Z",
          "updatedAt": "2021-07-27T16:16:34Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "NONE",
          "body": "So I don't think recommendations are necessary. I think bringing up the issue and the potential need for an API to indicate on per datagram if it is okay for this to be aggregated with other datagrams would be sufficient. \r\n",
          "createdAt": "2021-07-27T18:52:07Z",
          "updatedAt": "2021-07-27T18:52:07Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hm, I don't know if there needs to an API for this, that seems like an implementation-specific decision. I'd prefer to not add text for this, to let the applications that use datagrams be free in their usage.\r\n\r\nThat's not saying that HTTP/3, CONNECT-UDP, can't make recommendations, just that it doesn't need to belong here.",
          "createdAt": "2021-07-27T19:03:37Z",
          "updatedAt": "2021-07-27T19:03:37Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Section 5 and 5.1 mention the frame can be coalesced with other frames in a packet, and some of the multiplexing concerns. That seems like enough to me.\r\n\r\nThe suggestion for a specific API to mark non-coalescing reminds me of an issue I opened (and closed) a year ago - https://github.com/quicwg/datagram/issues/5. \r\n\r\nI think the text in 5.1 is already open enough to allow people to support this capability as part of a \"prioritization API\" if they wanted, saying anything more specific seems subjective and implementation territory - as David and Tommy have said.\r\n\r\n@gloinul I'd like to wrap this issue up and I'm not seeing much for the editors to do. Can we close it or do you have some specific proposal?",
          "createdAt": "2021-08-16T21:53:41Z",
          "updatedAt": "2021-08-16T21:53:41Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@gloinul are you okay to close this issue?",
          "createdAt": "2021-08-23T18:07:04Z",
          "updatedAt": "2021-08-23T18:07:11Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "NONE",
          "body": "Yes you may close this issue. I think what is in the editors copy are sufficient. ",
          "createdAt": "2021-08-26T08:21:10Z",
          "updatedAt": "2021-08-26T08:21:10Z"
        }
      ]
    },
    {
      "number": 42,
      "id": "MDU6SXNzdWU5NTYwMDc3Nzg=",
      "title": "Allow a Sender to Control Datagram ACKs",
      "url": "https://github.com/quicwg/datagram/issues/42",
      "state": "CLOSED",
      "author": "nibanks",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "In discussions with a few parties using MsQuic we've come along scenarios were ACKs for datagrams were either not necessary or they should (almost must) be not sent until some other data was being sent as well. While thinking through these, the simplest solution I've been able to come up with would be for a sender to indicate to the peer that it should not treat datagram frames as ACK eliciting. How do folks feel about adding another (optional) transport parameter to this spec, when present indicates DATAGRAM frames are not ack eliciting. Obviously, the parameter is simply ignored if the peer does not advertise support to receive the frames.",
      "createdAt": "2021-07-29T16:23:14Z",
      "updatedAt": "2021-09-16T20:05:01Z",
      "closedAt": "2021-09-16T20:05:01Z",
      "comments": [
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "@LPardue brought up a good point on Slack:\r\n\r\n> since datgrams are congestion controlled, if they don't get ACK'd, what would happen?\r\n\r\nMy response:\r\n\r\nGood point. A couple of thoughts:\r\n\r\nIn scenarios where the app is periodically (N datagrams a second) sending data, the ACKs will still be exchanged. Also, any other ACK eliciting data would trigger the exchange of ACKs as well.\r\n\r\nBut we still have the possible scenario of an app sending datagrams in a single direction, with no other feedback in response. I see two possible solutions:\r\n - Do nothing in the transport, but tell the app \"Don't do that!\"\r\n - Have logic in the transport to occasionally (every 1/4 * CWND?) include a PING frame to elicit an ACK to free up CWND.",
          "createdAt": "2021-07-29T16:28:13Z",
          "updatedAt": "2021-07-29T16:28:13Z"
        },
        {
          "author": "wegylexy",
          "authorAssociation": "NONE",
          "body": "How does _not acking_ affect idle timeout? i.e. client keeps sending datagrams, server never acks.",
          "createdAt": "2021-07-29T18:10:52Z",
          "updatedAt": "2021-07-29T18:10:52Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "https://datatracker.ietf.org/doc/html/rfc9000#section-10.1\r\n\r\n>    An endpoint restarts its idle timer when a packet from its peer is\r\n>    received and processed successfully.  An endpoint also restarts its\r\n>    idle timer when sending an ack-eliciting packet if no other ack-\r\n>    eliciting packets have been sent since last receiving and processing\r\n>    a packet.  Restarting this timer when sending a packet ensures that\r\n>    connections are not closed after new activity is initiated.\r\n\r\nSo receiving these packets would reset the idle timeout. Sending them would not, because they aren't ACK-eliciting.",
          "createdAt": "2021-07-29T18:35:16Z",
          "updatedAt": "2021-07-29T18:35:16Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We've been able to ship the DATAGRAM frame in production without this feature, so I'd suggest this should be written up as an extension to datagrams.",
          "createdAt": "2021-07-29T21:19:47Z",
          "updatedAt": "2021-07-29T21:19:47Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "+1 \r\n\r\nDatagrams has been tightly functionally scoped since adoption to the group. We have some IETF adopted protocols on top of QUIC that haven't seemed to need the suggested feature. Adding an optimization feature just as we're getting ready to ship has a bad track record. I think we'd want to see very strong evidence of usefulness and implementer intent of such a feature before considering it for inclusion.",
          "createdAt": "2021-07-29T21:31:49Z",
          "updatedAt": "2021-07-29T21:31:54Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "> I think we'd want to see very strong evidence of usefulness and implementer intent of such a feature before considering it for inclusion.\r\n\r\nFair enough. We intend to implement because the usefulness of this extends beyond HTTP scenarios to very general scenarios, including:\r\n\r\n1. Embedded/IoT/portable devices where network usage increases translate to battery life decreases\r\n2. Devices on metered networks where network usage increases translate to higher monetary costs\r\n\r\nGiven how general these scenarios are, I think we should take them into account within the main spec and not delay this for another document. While the spec may be sufficient for HTTP scenarios as-is, it would be a shame for a general transport spec to require an additional extension so it can be optimized for its use by non-HTTP callers who care more about the packet overhead.\r\n\r\nWould a repro of the packet reduction before and after the change be helpful to illustrate the impact of the change?",
          "createdAt": "2021-07-29T22:34:10Z",
          "updatedAt": "2021-07-29T22:34:10Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I could be lacking imagination but I'm not seeing why these problems are unique to DATAGRAM as currently defined. Rather it seems like the ability to reduce any QUIC traffic can benefit such use cases.\r\n\r\nAs an example, we've encountered something similar with the recommended ack policies in the base drafts and how something like ack-frequency can improve upon that for a range of documents.\r\n\r\nSeeing some number would be informative because right now this problem seems nebulous and the proposed solution a bit vague. ",
          "createdAt": "2021-07-29T22:45:24Z",
          "updatedAt": "2021-07-29T22:45:24Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "NONE",
          "body": "This seems like a fundamental change to the premise underlying the design of DATAGRAM frames. The choices to make them congestion controlled and ACK-eliciting were pretty deliberate, and I think making that optional serves to confuse the dependency graph of other drafts depending on DATAGRAM, as @LPardue alludes to.\r\n\r\nControlling ACKs is definitely an interesting problem, but I don't think this is pressing enough or specific to DATAGRAM to be in the DATAGRAM spec. One way to work around this, as discussed, is to make a new DATAGRAM type which doesn't elicit ACKs (more closely matching UDP datagram behavior). Such a thing is something that belongs in another extension, IMO.",
          "createdAt": "2021-07-29T22:51:25Z",
          "updatedAt": "2021-07-29T22:52:05Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "I agree that the general problem of \"how do we coalesce ACKs to minimize extra packets\" could be solved several ways. The ACK frequency extension is one way possible way (I initially started there, in fact). And yes, the problem _could_ be more generalized to data beyond DATAGRAMS, but there's a natural reason that at least two completely separate groups have come to me and asked for this for just DATAGRAMS: the data is unreliable and the apps have no direct need for the acknowledgements. I don't see this kind of behavior being as necessary for reliable data exactly because it is reliable. It needs to be retransmitted on loss. Therefore you need to determine loss and need those ACKs.\r\n\r\nAssuming then that we would only want to solve this for DATAGRAM, the question is \"How?\". Relying on the ACK frequency extensions has complications because we want to control the behavior based on the presence of the DATAGRAM frame. It seems overly complicated to say \"Please use this ACK frequency parameters, unless it's a DATAGRAM only frame, and then use these instead.\" That produces a pretty complicated implementation and API configuration surface. Configuring the interpretation of how you acknowledge DATAGRAM frames seems simpler: elicit an ACK or not. Can there be issues with congestion control? Yes. Can't you have exactly the same problem if you configured too high of an ACK frequency parameter set {1s delay; 1000pkt threshold)? Haven't heard any problems about that discussed with ACK frequency.\r\n\r\nI hoped to discuss possible solutions to the problem here. If the solutions ends up requiring a new document, then so be it. I can write a new document. I would like folks' opinions on the best way they think to solve this though.",
          "createdAt": "2021-07-30T00:12:24Z",
          "updatedAt": "2021-07-30T00:12:24Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Before we discuss *solutions* in the context of this draft, we should discuss *problems* in the context of this draft. The fact that there are multiple interoperable deployments of this drafts that haven't experienced this problems indicates that this problem is not applicable to all uses of this draft.",
          "createdAt": "2021-07-30T00:21:48Z",
          "updatedAt": "2021-07-30T00:21:48Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "I agree that the document works as is, for existing HTTP based scenarios/deployments, but as I understand it, the QUIC WG charter is no longer limited to purely HTTP based workloads. Therefore, is \"what we have works fine for HTTP\" still an acceptable reason to reject proposals related to non-HTTP problems?\r\n\r\nJust to restate the main problem: Battery operated embedded devices that periodically exchange DATAGRAM frames do not want to pay the power cost of waking up to send/receive the ACK-only packets that inevitably get exchanged, because the delayed ACK timer is less than the DATAGRAM send period. But simply increasing the delayed ACK timers has a negative side effect on reliable data that is occasionally exchanged. I understand that we don't want to have feature creep, but IMO, this is not an unreasonable problem to solve with this draft.\r\n\r\nThe simplest solution I've come up with is to allow for making DATAGRAMs not ACK-eliciting, as indicated in #44. Implementations (IMO) should be able to trivially implement the receiver part of this new TP (just treat it as an ACK or PADDING frame), and if they don't expect to ever send it, they don't need to add any extra code for it.",
          "createdAt": "2021-07-30T16:09:47Z",
          "updatedAt": "2021-07-30T16:09:47Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@nibanks this isn't about HTTP. We also have a VPN over QUIC DATAGRAM in production that works well without your proposed change. I think your proposal is in scope for the QUIC WG (though I'll defer to the chairs to make that call), it's just not necessarily in scope for this document. The DATAGRAM extension is general-purpose, whereas your proposal is constrained to a specific class of device. Figuring out how to solve your issue will take time, and I really don't think we should delay the publication of this document because of your specific constrained use-case.",
          "createdAt": "2021-07-30T16:14:19Z",
          "updatedAt": "2021-07-30T16:14:19Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "The proposal `max_datagram_no_ack` leaves open a big question about interoperability. If such a client finds it important not to have to do DATAGRAM-related ACK sending or receiving, then it's not clear what they do when a server doesn't advertise that `max_datagram_no_ack`. There's going to be other considerations like this that people would figure out experience - waiting on that before declaring this document done is unfair to the people that are happy with the work we adopted in the first place. \r\n\r\nWearing no hats, I think this use case has the potential to be interesting work worth addressing. If that requires QUIC protocol changes or extensions, the QUIC WG is best placed to do it. It doesn't sound like DATAGRAM prevents future work in that area.",
          "createdAt": "2021-07-30T16:33:30Z",
          "updatedAt": "2021-07-30T16:33:30Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "One comment I have related to possibly putting this in a separate document: It would then require two new transport parameters instead of just 1:\r\n\r\n- One TP for a peer to advertise support for the extension (and receiving the next TP).\r\n- One TP for actually disabling ACKs.\r\n\r\nThis would probably **double the implementation cost** because of the additional negotiation logic that would be required to implement along with what already exists for normal datagrams. The feature support matrix gets a lot more complicated.\r\n\r\n> The proposal `max_datagram_no_ack` leaves open a big question about interoperability.\r\n\r\nI don't quite follow the problem you outline here @LPardue. If my proposal were accepted, at a minimum an implementation that supports DATAGRAMs would have to support receiving the new TP, and simply modify their ACK logic accordingly. Implementations that have no need to send the TP don't need to do anything further.",
          "createdAt": "2021-07-30T16:42:53Z",
          "updatedAt": "2021-07-30T16:42:53Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "The problem statement is ambiguous then. You say that clients don't want to wake up to send or receive ACKs. If a server supports not ACKing the client DATAGRAM but doesn't send the extension to stop the client ack'ing server DATAGRAMs, is that ok?",
          "createdAt": "2021-07-30T16:50:18Z",
          "updatedAt": "2021-07-30T16:50:18Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "It's a unilateral extension where one side says \"Don't ACK my datagarms\" so they don't have to wake up just to process an ACK for the datagram. For protocols where it makes sense, both sides might enable it.",
          "createdAt": "2021-07-30T16:52:32Z",
          "updatedAt": "2021-07-30T16:52:32Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Thanks for the clarification. That seems to put a lot of onus on the receiver of the TP to do work. I.E you'd be asking server implementers to do work even if they have no intention to run deployments that requires this feature. ",
          "createdAt": "2021-07-30T17:07:16Z",
          "updatedAt": "2021-07-30T17:07:16Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "Yes, a receiver would have some burden, even if they don't have a corresponding scenario that enables the feature themselves. As I see it, the following changes are required (at a minimum):\r\n\r\n1. Add decoding logic for the new payload-less TP.\r\n2. Add a new connection-wide flag, that is set when the new TP is successfully decoded.\r\n3. When processing received DATAGRAM frames, read the flag and elicit an ACK accordingly.\r\n\r\nIMO, this is not \"a lot of onus\", especially if you compare it to some of the complexity involved in things like migration, ECN or SPA, which, strictly speaking, aren't explicitly required for a deployment to work, but still require a certain amount of work.",
          "createdAt": "2021-07-30T17:49:19Z",
          "updatedAt": "2021-07-30T17:49:45Z"
        },
        {
          "author": "wegylexy",
          "authorAssociation": "NONE",
          "body": "I think it is rather the reverse: server can opt to tell clients not to expect acks for datagrams that the client may send. This is essential for servers hosted in the cloud where egress is metered and ingress is free. If an old client doesn't support this, it will just assume the datagram is lost as usual.\r\nWhen this is enabled, the server will not ack datagrams at all, not even bundle with other frames. The app may already use stream to control the datagram payload from clients, e.g. server tells clients to lower voice quality via a control stream.",
          "createdAt": "2021-07-30T17:49:19Z",
          "updatedAt": "2021-07-30T17:49:19Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "@wegylexy yes, you could go that route, but I think it better for the sender of the DATAGRAMs to be in control, because only they know if they need ACKs or not.",
          "createdAt": "2021-07-30T17:50:59Z",
          "updatedAt": "2021-07-30T17:50:59Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "body": "An alternative way to spell this is analogous to PADDING/PING -- have an ack-eliciting-DATAGRAM and a non-ack-eliciting-DATAGRAM codepoint.",
          "createdAt": "2021-07-30T18:19:21Z",
          "updatedAt": "2021-07-30T18:19:21Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "Yes, that would be an acceptable approach. To expand a bit on the design/differences:\r\n\r\n1. No new TP; just defines two code point for the two type of frames: DATAGRAM & DATAGRAM_NO_ACK.\r\n2. DATAGRAMs are ACK-eliciting; DATAGRAM_NO_ACKs are not.\r\n\r\nIf folks think that's easier to implement on the receiver side, I'd be fine with that as well.",
          "createdAt": "2021-07-30T18:24:42Z",
          "updatedAt": "2021-07-30T18:24:42Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "_typed my answer but got overtaken by events, but posting any way_ \r\n\r\nThe alternative I offered in slack was was to define a new frame type called DATAGRAM_NO_ACK that acts very much like DATAGRAM except it is not ack-eliciting. Endpoints advertise their willingness to receive the frame in a TP, if your peer doesn't support it then you know to either fall back to a less optimized DATAGRAM (maybe with some ACK tuning) or you terminate everything. The requirement on what to do with that individual frame is clear. The onus shifts to the sender to make sure they use the frames appropriately. It also allows a sender to mix in a regular DATAGRAM to ellicit acks when its needed, avoiding the need for pings. \r\n\r\nI think this goes to show that even iff the WG were to agree to solve this problem, we'll take time to agree on the solution acceptable to everyone with an opinion, implementation or deployment concerns.\r\n\r\n> migration, ECN or SPA, which, strictly speaking, aren't explicitly required for a deployment to work, but still require a certain amount of work.\r\n\r\nIn those examples, the peer can't force the endpoints to use the feature. Those examples are also complicated and require page(s) of text to explain the expectations, tradeoffs etc. That's why I'm concerned about tying up the DATAGRAM progress with something that might have considerations we don't know about.",
          "createdAt": "2021-07-30T18:29:29Z",
          "updatedAt": "2021-07-30T18:29:29Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1. None of these proposals have anywhere near as much deployment as existing DATAGRAM. We should experiment with these, but not in a way that delays shipping the datagram document.",
          "createdAt": "2021-07-30T18:51:49Z",
          "updatedAt": "2021-07-30T18:51:49Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "One way to approach experimentation would be to collect the problem statement and the different proposals into a single I-D, and solicit feedback to gain a sense of whether the community shares the understanding of the problem and has any strong opinion for one of the proposals, or indeed has other ideas. ",
          "createdAt": "2021-08-03T14:54:47Z",
          "updatedAt": "2021-08-03T14:54:47Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, I think having a new document with a problem statement and proposal would be best here.\r\n\r\nI'd point out that the document does give implementations a fair amount of leeway:\r\n\r\n```\r\nReceivers SHOULD support delaying ACK frames (within the limits specified by max_ack_delay) in reponse to receiving packets that only contain DATAGRAM frames, since the timing of these acknowledgements is not used for loss recovery.\r\n```\r\n\r\nSo, implementations can choose to be fairly lazy in sending ACKs, and can configure a high max_ack_delay. If this really isn't sufficient, I think we need a new proposal.",
          "createdAt": "2021-08-06T16:59:33Z",
          "updatedAt": "2021-08-06T16:59:33Z"
        },
        {
          "author": "wegylexy",
          "authorAssociation": "NONE",
          "body": "@tfpauly What about low delay for streams but high delay for datagrams? And priority of packets and their acks between streams and datagrams?",
          "createdAt": "2021-08-06T19:38:38Z",
          "updatedAt": "2021-08-06T19:38:38Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "An implementation certainly could ACK with larger delays for DATAGRAM-only packets, and shorter delays for packets with STREAM frames. The document already suggests this. However, since ACKs are for packets, not frames, I don't see how prioritization comes into play: once I receive a STREAM frame I can ACK more quickly, which then also covers any DATAGRAM-only packets I had received. ",
          "createdAt": "2021-08-06T19:42:22Z",
          "updatedAt": "2021-08-06T19:42:22Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@nibanks are you okay to say this is not in scope for the main doc, and take it as a separate discussion in the WG?",
          "createdAt": "2021-08-23T18:06:25Z",
          "updatedAt": "2021-08-23T18:06:25Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "In my opinion, this should be included in the core datagram extension. There are two main questions in play here:\r\n\r\n### Should a DATAGRAM sender be allowed to control the ACK behavior?\r\n\r\nThere are many reasons that a QUIC-based protocol would want to control the ACK behavior:\r\n\r\n1. Low power (IoT) devices that have no need/desire to wake up to process an ACK (e.g. sensor periodically sending some state).\r\n2. A need to customize the ACK batching for non-power related reasons, such as more expensive ingress/egress traffic.\r\n3. Generally, more flexibility for existing UDP-based protocols to be ported to QUIC.\r\n\r\nAs already mentioned, packets with DATAGRAM frames are congestion controlled, so senders must be warry and account for this. IMO, there a several ways to handle this and should not be a blocker.\r\n\r\nIf the WG agrees that we should support this, then the following, more contentious, question comes in:\r\n\r\n### Should all DATAGRAM receivers be REQUIRED to support this?\r\n\r\nIn other words, can we make this feature optional (i.e. put it in a separate extension) or not? The only part that would be required if this was added to the DATAGRAM spec is the receiving part, because an implementation doesn't have to send things it doesn't use itself; but it does have to ACK them.\r\n\r\nArguments for making it required:\r\n\r\n- This core DATAGRAM spec is adding a fundamentally new way to exchange data between applications: unreliably. This is an extremely useful feature and lots of different protocols are looking at using this, and the spec should take all of these into account. All reasonable uses of these should be considered in scope. This is all about exchanging data unreliably and the spec should consider both directions of that exchange. Many protocols that need unreliable data on a QUIC connection will not want an explicit ACK to be sent.\r\n\r\n- The additional complexity on an implementation is minimal. A receiver must support treating the DATAGRAM frames just like PADDING if the sender indicates this. It is not required to support the send path if its scenarios (HTTP/3-based?) have no immediate need for it.\r\n\r\nArguments against making it optional:\r\n\r\n- It doubles the failure/edge conditions involved with connection setup. The protocol needs additional logic to handle if the core extension is/isn't enabled, combined with if the new extension is/isn't enabled. This additional logic is much more complicated and error prone, compared to the receiver just treating DATAGRAMSs like PADDING when ACKing.\r\n\r\nResponses to arguments that have been made against requiring it:\r\n\r\n**Existing deployments don't need it.**\r\n\r\nThe spec should take into account more than the current deployments' usages. Other protocols actively looking to use QUIC will use it.\r\n\r\n**We require interop'ing code before requiring anything.**\r\n\r\nIMO, as things stand currently, this is effectively a requirement to interop with an HTTP/3 stack. As far as I know, beyond MsQuic, there are no other deployed QUIC-based protocols beyond HTTP/3. All the existing production implementations and deployments involve HTTP/3. So if there is a feature that existing HTTP/3 stacks have no interest in, there's no way to get interop with those stacks because they won't implement the feature.\r\n\r\nTaking all this into account, my strong preference is to make this a requirement of the core DATAGRAM extension, ideally along the lines of https://github.com/quicwg/datagram/pull/45.",
          "createdAt": "2021-09-03T12:49:53Z",
          "updatedAt": "2021-09-03T15:08:51Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Personally, I think that the use case of QUIC being optimized for IoT devices to the point that it can be used for sending beacon packets without any ACKs or congestion control is out of scope of this document, and belongs as an extension. I think that kind of use case goes beyond just adding unreliable frame support, and needs a lot more advice and changes made to the protocol as a whole, particularly around loss recovery and congestion control.\r\n\r\nAs such, I do not believe this should be a required feature for unreliable DATAGRAM support.",
          "createdAt": "2021-09-03T16:29:03Z",
          "updatedAt": "2021-09-03T16:29:03Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "Thanks for the feedback Tommy.\r\n\r\n> can be used for sending beacon packets without any ACKs or congestion control is out of scope of this document\r\n\r\nI think it's an important distinction to tease out: Congestion control still applies 100%. No changes there. Additionally, we aren't doing \"without **any** ACKs\". Congestion control will still limit the amount that can go into the network. We will still require ACKs to remove \"bytes in flight\" to free up the CC window.\r\n\r\n> QUIC being optimized for IoT devices ... is out of scope of this document\r\n\r\nI'd like to clarify this statement further, if possible. Are you saying that in general QUIC for IoT devices is out of scope or were you referring specifically to the ACK/CC stuff (discussed above)? If IoT in general, there is nothing explicitly IoT for this from a protocol stand point. Additionally, TCP, UDP, and TLS don't have a \"here's the IoT specific bits\" associated specs or extensions that I know of. Why should QUIC be any different? If the statement was specific to the ACK/CC stuff, please see my above comments.\r\n\r\n>  that kind of use case goes beyond just adding unreliable frame support\r\n\r\nAssuming you ignore the statement about changing CC (which I am not proposing) and that ACKs are still generally required for all other aspects of the protocol, I strongly believe being able to modify that ACK behavior of the peer for datagrams is in scope for this spec. I see a similar correlation between PING/PADDING in the core spec.",
          "createdAt": "2021-09-03T16:53:54Z",
          "updatedAt": "2021-09-03T16:53:54Z"
        },
        {
          "author": "Ralith",
          "authorAssociation": "NONE",
          "body": "> As far as I know, beyond MsQuic, there are no other deployed QUIC-based protocols beyond HTTP/3. All the existing production implementations and deployments involve HTTP/3.\r\n\r\nFWIW, quinn implements features regardless of their relevance to HTTP/3, and has non-HTTP/3 users, and considers good datagram support a priority. We're a bit behind on interop setup, though.",
          "createdAt": "2021-09-03T17:00:23Z",
          "updatedAt": "2021-09-03T17:00:23Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If we are still requiring that DATAGRAMs contribute to bytes in flight, but are allowed to not be ACK'ed, we get into the warnings that are around PADDING:\r\n\r\n```\r\nTo avoid a deadlock, a sender SHOULD ensure that other frames are sent periodically in addition to PADDING frames to elicit acknowledgments from the receiver.\r\n```\r\n\r\nNow, it seems unlikely that a QUIC sender would only ever be sending PADDING packets to the point where the a deadlock occurs, but it's quite reasonable to only send DATAGRAM packets for quite a while. Thus this would require that senders also send PINGs to elicit ACKs, and be very careful about doing so to avoid deadlocks.\r\n\r\nThe other way to minimize ACK overhead is to instead delay ACKs, which is what the document already suggests. max_ack_delay can go up to 16 seconds if that's how a specific application wants to configure things. For the use cases you have, is there a hard requirement to have ACKs spread out longer than 16 seconds? The spec can support a truly huge amount of ACK batching.\r\n\r\nAlso, regarding implementation, our implementation for the Apple stack (which is now public API) is QUIC-native without requiring HTTP/3, so I am certainly looking at use cases beyond HTTP/3.",
          "createdAt": "2021-09-03T18:16:36Z",
          "updatedAt": "2021-09-03T18:16:36Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "The problem with increasing delayed ACK is its effect on reliable data. IMO, this further argues for why something like this should be in the DATAGRAM spec, and not something else. We don't want to effect reliable data acknowledgements; just the unreliable data.",
          "createdAt": "2021-09-03T18:28:33Z",
          "updatedAt": "2021-09-03T18:28:33Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "@nibanks if you want datagrams to not be acknowledged, then logically they should be exempted of congestion control. And then, I would really not want that to be a default or must-support option. If the application really depends on that behavior, why is it not using DTLS instead of QUIC?",
          "createdAt": "2021-09-03T18:31:52Z",
          "updatedAt": "2021-09-03T18:31:52Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "@huitema they are still acknowledged. They just don't always need to elicit an immediate ACK. As far as using DTLS, QUIC brings loads of features and improvements compared to DTLS when considering reliable data delivery. Apps that **only** need unreliable delivery aren't the target scenario; apps/protocols that need a mix a reliable and unreliable are.",
          "createdAt": "2021-09-03T18:41:41Z",
          "updatedAt": "2021-09-03T18:41:41Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@nibanks the ACK delay is the _max_ ACK delay. Essentially, you can ACK STREAM frames faster if you want\u2014you don't have to delay\u2014but you can delay ACKs for DATAGRAMs for quite a while. This seems like it's very doable for specific applications.",
          "createdAt": "2021-09-03T19:14:57Z",
          "updatedAt": "2021-09-03T19:14:57Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "The chairs have been monitoring the discussion on this issue, PRs, and Slack.\r\n\r\nThe DATAGRAM draft was adopted as a simple extension to QUIC that operated within the existing constraints and premises of the core QUIC transport. The ACK-eliciting property of DATAGRAM frames was included in the version of the document that this WG chose to adopt. Treating them this way provides similarity to STREAM frames, which aids user expectations of application data behaviour, and is consistent with the design principle that DATAGRAM frames are subject to congestion control.\r\n\r\nDATAGRAM is an extension to QUIC. Endpoints advertise their ability to receive DATAGRAM frames. Applications that build on top of QUIC need to define handling of this extension negotiation and failure conditions.\r\n\r\nThe stated goals for this proposal can, in part, be achieved by existing QUIC capabilities such as ACK delaying. Where there is a capability gap, the core QUIC transport and DATAGRAM draft do not prevent additional extensions that can fulfil the stated goals. It has been noted that there may be pain for applications that require specific QUIC extensions in order to meet an operational target. The chairs do not believe this problem is unique to DATAGRAM and is something that application will have to accommodate in the long term.\r\n\r\nSeveral members of the WG have noted that changing or augmenting the ACK behaviour of DATAGRAM introduces complication for the design of this extension specifically related to congestion control. For what is a fairly short draft, accommodating a robust and complete solution to this proposal would likely require broad changes of design and editorial nature to this specification. Furthermore, incorporating such a design change as a mandatory part of DATAGRAM risks requiring IETF work items dependent on this specification to also exert effort to accommodate the change. The chairs note that the current design meets the operational targets of IETF protocols such as MASQUE and WebTransport. Meanwhile, while discussion for audio/video use-cases of QUIC seems to be picking up in the IETF (for example the [non-WG MoQ list](https://mailarchive.ietf.org/arch/browse/moq/). It is still early in understanding how DATAGRAM meets or does not meet evolving application needs. Attempting to accommodate emerging needs puts at risk the WGs ability to complete work for dependent applications that already have their needs solved. This is a matter of trade-offs.\r\n\r\nQUIC's strong versioning and extensibility support mean that it can be tailored to the needs or requirements of applications, without necessarily needing coordination between diverse implementers, endpoints, or the QUIC WG. When deciding what work to take on in the QUIC WG, the chairs consider interest from the WG members in both solving the problem and implementing the solution.\r\n\r\nBased on our observations of the discussion on this issue, together with the progress status of the DATAGRAM specification, the chairs do not believe there is sufficient interest in the WG such that this problem needs to be solved as part of this document. The proposal therefore is to close the issue with no action. A consensus call will be sent to the mailing list.\r\n\r\nThe chairs would like to note that a non-ack eliciting DATAGRAM extension is in scope of the QUIC WG should the proponents wish to pursue the work as a separate item.\r\n\r\n\r\n",
          "createdAt": "2021-09-08T11:12:44Z",
          "updatedAt": "2021-09-08T11:12:44Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "NONE",
          "body": "I'm just coming into this discussion now, but I support not doing anything in the core datagram draft and instead punting this to the ack-frequency draft.\r\n\r\nI already filed an issue for a frame that makes a packet non-ack-eliciting(https://github.com/quicwg/ack-frequency/issues/65), but there are other ways this could be done(ie: A very high 'ACK-Eliciting Threshold') as well.\r\n\r\n",
          "createdAt": "2021-09-08T12:35:07Z",
          "updatedAt": "2021-09-08T12:35:07Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "NONE",
          "body": "Just a note to the proponents who might still want to see this work happen elsewhere. As you work through building a case for this, I think it might help if you:\r\n\r\n- build a PoC. ACKs are pretty fundamental to QUIC, so a PoC of QUIC working actually working would be super helpful.\r\n- describe the changes required to congestion controller and loss detection mechanisms. This part is going to be necessary to understand how to reason about such a mechanism.\r\n- lay out the value of doing this beyond reducing ACK frequency. The cost of doing this sort of thing might be quite a bit, probably mostly in terms of reasoning about it.\r\n\r\nIn general, I'll note that a receiver is free to do as it chooses, and it can unilaterally ack (or not) when it wants. The entire point of the ack-frequency draft is for the sender to tell the receiver of its tolerance, to put limits on how long the receiver might delay acks. You might consider building something with a combination of sender tolerance signaling (through ack frequency) and general receiver behavior (through application negotiation, or through a TP, to indicate that a receiver does not need to ack some things immediately).\r\n\r\n",
          "createdAt": "2021-09-13T20:36:30Z",
          "updatedAt": "2021-09-13T20:37:01Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Consensus is to close this with no action on the DATAGRAM spec.",
          "createdAt": "2021-09-16T20:05:01Z",
          "updatedAt": "2021-09-16T20:05:01Z"
        }
      ]
    },
    {
      "number": 43,
      "id": "MDU6SXNzdWU5NTYyNjM3NzA=",
      "title": "Please define the frame using RFC 9000 style",
      "url": "https://github.com/quicwg/datagram/issues/43",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "If you're receptive to this suggestion I am happy to file a PR",
      "createdAt": "2021-07-29T22:57:45Z",
      "updatedAt": "2021-08-06T16:50:23Z",
      "closedAt": "2021-08-06T16:50:23Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Oh wow I hadn't realized that we never updated to the new style. A PR would be lovely please!",
          "createdAt": "2021-07-29T23:07:19Z",
          "updatedAt": "2021-07-29T23:07:19Z"
        }
      ]
    },
    {
      "number": 47,
      "id": "MDU6SXNzdWU5NzE5OTY4NzA=",
      "title": "Question about: \"not used for loss recovery\"",
      "url": "https://github.com/quicwg/datagram/issues/47",
      "state": "CLOSED",
      "author": "ddragana",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Can someone explain why the ack from Datagram-only packets are not used for loss recovery?\r\n\r\n> Receivers SHOULD support delaying ACK frames (within the limits specified by max_ack_delay) in reponse to receiving packets that only contain DATAGRAM frames, since the timing of these acknowledgements is not used for loss recovery.\r\n\r\nI would appreciate if someone can point me to an existing discussion or explanation. Thanks.",
      "createdAt": "2021-08-16T18:30:53Z",
      "updatedAt": "2021-08-31T22:02:18Z",
      "closedAt": "2021-08-31T22:02:18Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's because datagram-only packets don't contain any frames that need to be retransmitted - so there's no recovery to be done. In other words: what was lost doesn't need to be retransmitted. Therefore it's not urgent to let the peer know that this packet was lost because the peer isn't rushing to retransmit anything.",
          "createdAt": "2021-08-16T20:46:37Z",
          "updatedAt": "2021-08-16T20:46:37Z"
        },
        {
          "author": "ddragana",
          "authorAssociation": "NONE",
          "body": "> That's because datagram-only packets don't contain any frames that need to be retransmitted - so there's no recovery to be done. In other words: what was lost doesn't need to be retransmitted. Therefore it's not urgent to let the peer know that this packet was lost because the peer isn't rushing to retransmit anything.\r\n\r\nSide note: the last sentence is not correct: the  peer does not know that the packet only contains Datagram frames, because the packet has been lost.\r\n\r\nBack to the original text quoted above. The ack for a Datagram-only packet can still be use to detect loss of other packets, therefore it may be used for loss recovery. In my opinion it should be treated the same as the other ack-eliciting packets. Can we improve he sentence?\r\n",
          "createdAt": "2021-08-16T21:34:18Z",
          "updatedAt": "2021-08-16T21:34:18Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Side note: the last sentence is not correct: the peer does not know that the packet only contains Datagram frames, because the packet has been lost.\r\n\r\nIn that sentence, the peer was the endpoint who sent the datagram-only packet, so they know what frames it contains. Apologies if that was unclear.\r\n\r\n> Back to the original text quoted above. The ack for a Datagram-only packet can still be use to detect loss of other packets, therefore it may be used for loss recovery. In my opinion it should be treated the same as the other ack-eliciting packets. Can we improve he sentence?\r\n\r\nThose aren't mutually exclusive. If you receive a train of many datagram-only packets, it is useful to delay acks. If you receive a datagram-only packet whose packet number is more than one apart from the previous packet you saw, then it's indicative of a lost (or reordered) packet so you can act on that to trigger a more urgent ack, regardless of the frame content of the latest received packet.\r\n\r\nBut it's possible we can improve the phrasing in the draft. Do you have a proposal in mind?",
          "createdAt": "2021-08-16T22:16:15Z",
          "updatedAt": "2021-08-16T22:16:15Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "body": "It feels like the key realization chain here is:\r\n\r\n- DATAGRAM-only packets have nothing to retransmit if they're lost\r\n- Therefore, senders don't need to keep the payload of these packets around in case they need to retransmit them\r\n- Therefore, receipt of an acknowledgement for a DATAGRAM-only packet frees minimal resources on the sender's side\r\n- Therefore, it's not urgent for receivers to signal that they successfully received a DATAGRAM-only packet\r\n\r\nSo perhaps something like:\r\n\r\n>Receivers SHOULD support delaying ACK frames (within the limits specified by max_ack_delay) in response to receiving packets that only contain DATAGRAM frames, since the sender takes no action if these packets are temporarily unacknowledged.  Receivers SHOULD continue to send ACK frames when conditions indicate a packet might be lost, since the packet's payload is unknown to the receiver, and when dictated by max_ack_delay or other protocol components.\r\n\r\nNote also \"reponse\" => \"response\"",
          "createdAt": "2021-08-17T15:25:28Z",
          "updatedAt": "2021-08-17T15:26:00Z"
        },
        {
          "author": "ddragana",
          "authorAssociation": "NONE",
          "body": "Thanks. That is more clear. ",
          "createdAt": "2021-08-17T19:08:49Z",
          "updatedAt": "2021-08-17T19:08:49Z"
        }
      ]
    },
    {
      "number": 49,
      "id": "I_kwDODoD7Ms47X0YA",
      "title": "The ",
      "url": "https://github.com/quicwg/datagram/issues/49",
      "state": "CLOSED",
      "author": "wangweiwei1188",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The draft-ietf-quic-datagram has the following words: This frame SHOULD be sent as soon as possible, and MAY be coalesced with other frames.If one DATAFRAM frame is coalesced  with STREAM frame in one QUIC packet.And the QUIC packet is lost by the middlebox, according to the rfc9000, the quic packet must be retransmission, But the DATAFRAM frame do not need retransmission.",
      "createdAt": "2021-09-14T14:38:42Z",
      "updatedAt": "2021-09-14T14:39:23Z",
      "closedAt": "2021-09-14T14:39:23Z",
      "comments": []
    },
    {
      "number": 50,
      "id": "I_kwDODoD7Ms47X1Bk",
      "title": "Question about\uff1aThis frame SHOULD be sent as soon as possible, and MAY be coalesced with other frames",
      "url": "https://github.com/quicwg/datagram/issues/50",
      "state": "CLOSED",
      "author": "wangweiwei1188",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The draft-ietf-quic-datagram has the following words: This frame SHOULD be sent as soon as possible, and MAY be coalesced with other frames.If one DATAFRAM frame is coalesced with STREAM frame in one QUIC packet.And the QUIC packet is lost by the middlebox, according to the rfc9000, the quic packet must be retransmission, But the DATAFRAM frame do not need retransmission.",
      "createdAt": "2021-09-14T14:41:14Z",
      "updatedAt": "2021-09-14T16:23:11Z",
      "closedAt": "2021-09-14T16:23:11Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "QUIC does not retransmit packets, it retransmits application data, see [Section 13.3 of RFC 9000](https://datatracker.ietf.org/doc/html/rfc9000#section-13.3). In your example, the data from the STREAM frame would be retransmitted but not the data from the DATAGRAM frame.",
          "createdAt": "2021-09-14T14:44:51Z",
          "updatedAt": "2021-09-14T14:44:51Z"
        },
        {
          "author": "wangweiwei1188",
          "authorAssociation": "NONE",
          "body": "Okay, Thanks.",
          "createdAt": "2021-09-14T16:23:05Z",
          "updatedAt": "2021-09-14T16:23:05Z"
        }
      ]
    },
    {
      "number": 51,
      "id": "I_kwDODoD7Ms47YNZO",
      "title": "Can DATAGRAM frame belong to stream?",
      "url": "https://github.com/quicwg/datagram/issues/51",
      "state": "CLOSED",
      "author": "wangweiwei1188",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The draft-ietf-quic-datagram has the following words: DATAGRAM frames belong to a QUIC connection as a whole, and are not strongly associated with any stream ID at the QUIC layer.\r\nCan DATAGRAM belong to stream?  And one stream has two type: one for unreliable transmission(DATAGRAM FRAME) and another one for reliable transmission(STREAM FRAME).",
      "createdAt": "2021-09-14T16:18:56Z",
      "updatedAt": "2021-09-15T14:23:52Z",
      "closedAt": "2021-09-15T14:23:52Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "At the QUIC layer, datagrams don't belong to streams. In HTTP/3 however, datagrams are associated with streams - see [draft-ietf-masque-h3-datagram](https://datatracker.ietf.org/doc/html/draft-ietf-masque-h3-datagram) for details.",
          "createdAt": "2021-09-14T17:45:07Z",
          "updatedAt": "2021-09-14T17:45:07Z"
        },
        {
          "author": "wangweiwei1188",
          "authorAssociation": "NONE",
          "body": "OK, Thanks.",
          "createdAt": "2021-09-15T14:23:45Z",
          "updatedAt": "2021-09-15T14:23:45Z"
        }
      ]
    },
    {
      "number": 52,
      "id": "I_kwDODoD7Ms47iDD9",
      "title": "Not \"strongly\" associated",
      "url": "https://github.com/quicwg/datagram/issues/52",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "From list discussion:\r\n\r\n>       DATAGRAM frames belong to a QUIC connection as a whole, and are not \r\n>       strongly associated with any stream ID at the QUIC layer\r\n\r\nWhat does \"strongly associated\" mean in this context?\r\n\r\nWe should remove \"strongly\".",
      "createdAt": "2021-09-17T00:04:51Z",
      "updatedAt": "2021-09-17T01:59:39Z",
      "closedAt": "2021-09-17T01:59:39Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree, removing strongly seems best",
          "createdAt": "2021-09-17T00:17:46Z",
          "updatedAt": "2021-09-17T00:17:46Z"
        }
      ]
    },
    {
      "number": 54,
      "id": "I_kwDODoD7Ms47mDVW",
      "title": "Question about DATAGRAM frame",
      "url": "https://github.com/quicwg/datagram/issues/54",
      "state": "CLOSED",
      "author": "wangweiwei1188",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The draft has the following words:\r\nThis document defines two new DATAGRAM QUIC frame types, which carry application data without requiring retransmissions.\r\n\r\nThe draft don't describe it like:When DATAGRAM frame is lost, the implemention  should not retransmission it.That's to say, when DATAGRAM  frame's lost, the implemention have two strategy\uff0cone for retransmissing, another for not.That's right?",
      "createdAt": "2021-09-18T02:19:09Z",
      "updatedAt": "2021-09-18T14:41:43Z",
      "closedAt": "2021-09-18T14:41:42Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "DATAGRAM frames are never retransmitted. The reason there are technically two frame types is that there\u2019s a version that includes it\u2019s length, and a version that just extends to the end of the packet. That\u2019s just like STREAM frames.\r\n\r\nDoes this answer your question @wangweiwei1188 ?",
          "createdAt": "2021-09-18T13:07:37Z",
          "updatedAt": "2021-09-18T13:07:37Z"
        },
        {
          "author": "wangweiwei1188",
          "authorAssociation": "NONE",
          "body": "Yeah, Thanks.",
          "createdAt": "2021-09-18T14:41:28Z",
          "updatedAt": "2021-09-18T14:41:28Z"
        }
      ]
    },
    {
      "number": 56,
      "id": "I_kwDODoD7Ms48HHMW",
      "title": "Is reliability really stream-based?",
      "url": "https://github.com/quicwg/datagram/issues/56",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In the introduction, it says\r\n\"Reliability within QUIC is performed on a per-stream basis, so some frame types are not eligible for retransmission\"\r\n\r\nIs it really per-stream? Some frames are retransmitted even though they aren't associated with a stream.\r\n\r\nReally, the detection mechanism is packet-based, the retransmission decision is made on a per-frame basis, and for stream-specific frames there is the added consideration of stream state (i.e. do not resend if reset)\r\n\r\nI suggest replacing the sentence above with \"Some QUIC frame types are not eligible for retransmission.\"",
      "createdAt": "2021-09-27T19:10:09Z",
      "updatedAt": "2021-09-28T02:40:06Z",
      "closedAt": "2021-09-28T02:40:06Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> In the introduction, it says\r\n> \"Reliability within QUIC is performed on a per-stream basis, so some frame types are not eligible for retransmission\"\r\n> \r\n> Is it really per-stream? Some frames are retransmitted even though they aren't associated with a stream.\r\n\r\nDo you have examples? It's common for an action to be attempted again, but not for the frame to be retransmitted.\r\n\r\n> Really, the detection mechanism is packet-based, the retransmission decision is made on a per-frame basis, and for stream-specific frames there is the added consideration of stream state (i.e. do not resend if reset)\r\n\r\nThat's not quite right. QUIC does not retransmit stream frames, it instead looks at stream state to see what data needs to be retransmitted - there's an important conceptual difference there: let's say you had 100 bytes left in your packet and therefore sent 98 bytes of stream data and that got lost but now you have a full 1200 payload available, you shouldn't retransmit that 100 byte STREAM frame and instead create a new STREAM frame with as much data as you want to send.\r\n\r\n[RFC 9000 s2.2](https://datatracker.ietf.org/doc/html/rfc9000#section-2.2) states:\r\n> Streams are an ordered byte-stream abstraction with no other structure visible to QUIC.  STREAM frame boundaries are not expected to be preserved when data is transmitted, retransmitted after packet loss, or delivered to the application at a receiver.",
          "createdAt": "2021-09-27T19:21:21Z",
          "updatedAt": "2021-09-27T19:21:21Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So I agree with everything you're saying factually; this is an editorial, semantic gripe about what it means that reliability is on a per-stream basis and what it means that a frame is retransmitted.\r\n\r\nIt's true that, for example, MAX_DATA frames aren't resent verbatim, but RFC 9000 addresses them in a section called \"retransmission of information\" due to the common-sense meaning of the term.\r\n\r\nWhat are you trying to communicate by saying that reliability is \"on a per-stream basis\"?\r\n\r\n",
          "createdAt": "2021-09-27T19:32:46Z",
          "updatedAt": "2021-09-27T19:32:46Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that this sentence is confusing. Perhaps we just remove it entirely? @tfpauly @ekinnear thoughts?",
          "createdAt": "2021-09-27T19:58:45Z",
          "updatedAt": "2021-09-27T19:58:45Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@DavidSchinazi @martinduke made a proposal with #58 ",
          "createdAt": "2021-09-27T22:01:22Z",
          "updatedAt": "2021-09-27T22:01:22Z"
        }
      ]
    },
    {
      "number": 59,
      "id": "I_kwDODoD7Ms48iWDE",
      "title": "State clearly the IANA registration type of TP and frame type",
      "url": "https://github.com/quicwg/datagram/issues/59",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Noticed during the shepherd writeup of IANA considerations:\r\n\r\nThe document is attempting to register:\r\n\r\n- max_datagram_frame_size Transport Parameter with value 0x0020\r\n- DATAGRAM frame type with values 0x30 and 0x31\r\n\r\nAccording to IANA (https://www.iana.org/assignments/quic/quic.xhtml) registrations can be of different types. Here the requested values are in the `permanent, 0x00-0x3f | Standards Action or IESG Approval` bracket. \r\n\r\nSo I suggest that the document state clearly that this is a request for permanent registration of these types.\r\n\r\n\r\n\r\n ",
      "createdAt": "2021-10-04T21:08:00Z",
      "updatedAt": "2021-10-05T13:47:35Z",
      "closedAt": "2021-10-05T13:47:35Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed. Wrote up #60 to fix this.",
          "createdAt": "2021-10-04T21:13:40Z",
          "updatedAt": "2021-10-04T21:13:40Z"
        }
      ]
    },
    {
      "number": 61,
      "id": "I_kwDODoD7Ms48iX-R",
      "title": "Why do IANA considerations duplicate information from the body?",
      "url": "https://github.com/quicwg/datagram/issues/61",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Noticed during Shepherd review.\r\n\r\nAll of the core types registered in RFC 9000 simply link to the relevant document (RFC 9000) and section in the document where the protocol element is defined. \r\n\r\nIn contrast, in datagram's IANA considerations section, the transport parameter and frame type registrations include the required `specification` field with some text that is already included in the document. This will manifest as a weird juxtaposition in the IANA table.\r\n\r\nI suggest you simply reference the section 3 and section 4 respectively. If you really want some prose (I don't recommend that) then it can be added as a note to the table.",
      "createdAt": "2021-10-04T21:17:27Z",
      "updatedAt": "2021-10-05T13:47:35Z",
      "closedAt": "2021-10-05T13:47:35Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I noticed that when writing #60 and I agree, we should just list \"This specification\" in there as most RFCs do.",
          "createdAt": "2021-10-04T21:20:24Z",
          "updatedAt": "2021-10-04T21:20:24Z"
        }
      ]
    },
    {
      "number": 63,
      "id": "I_kwDODoD7Ms48uh6Y",
      "title": "Clarify 0-RTT handling",
      "url": "https://github.com/quicwg/datagram/issues/63",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Section 3 says:\r\n\u201cAn endpoint MUST NOT send DATAGRAM frames until it has received the max_datagram_frame_size transport parameter with a non-zero value.\u201d\r\n \r\nI guess you assume that having received max_datagram_frame_size in a previous connection, when 0-RTT is used, counts but interpreting this MUST strictly, you cannot send datagrams in 0-RTT. Maybe that can be clarified.\r\n \r\nAlso if datagrams are used with 0-RTT but for some reason are not supported by the server anymore, it would actually be useful to have a more specific error message if the connection is closed by the server.",
      "createdAt": "2021-10-06T17:33:58Z",
      "updatedAt": "2022-01-14T17:42:41Z",
      "closedAt": "2022-01-14T17:42:41Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Section 3 says: \u201cAn endpoint MUST NOT send DATAGRAM frames until it has received the max_datagram_frame_size transport parameter with a non-zero value.\u201d\r\n> \r\n> I guess you assume that having received max_datagram_frame_size in a previous connection, when 0-RTT is used, counts but interpreting this MUST strictly, you cannot send datagrams in 0-RTT. Maybe that can be clarified.\r\n\r\nThis is already discussed in Section 3:\r\n```\r\n   When clients use 0-RTT, they MAY store the value of the server's\r\n   max_datagram_frame_size transport parameter.  Doing so allows the\r\n   client to send DATAGRAM frames in 0-RTT packets.  When servers decide\r\n   to accept 0-RTT data, they MUST send a max_datagram_frame_size\r\n   transport parameter greater or equal to the value they sent to the\r\n   client in the connection where they sent them the NewSessionTicket\r\n   message.  If a client stores the value of the max_datagram_frame_size\r\n   transport parameter with their 0-RTT state, they MUST validate that\r\n   the new value of the max_datagram_frame_size transport parameter sent\r\n   by the server in the handshake is greater or equal to the stored\r\n   value; if not, the client MUST terminate the connection with error\r\n   PROTOCOL_VIOLATION.\r\n```\r\n\r\n> Also if datagrams are used with 0-RTT but for some reason are not supported by the server anymore, it would actually be useful to have a more specific error message if the connection is closed by the server.\r\n\r\nThat's not how 0-RTT works in QUIC. If the server wishes to no longer support datagrams, it MUST reject 0-RTT data and therefore it won't see those DATAGRAM frames.",
          "createdAt": "2021-10-06T18:56:03Z",
          "updatedAt": "2021-10-06T18:56:03Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mirjak given David's explanation, are we OK to close this one?",
          "createdAt": "2021-10-06T20:00:59Z",
          "updatedAt": "2021-10-06T20:00:59Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "NONE",
          "body": "I know that this is explained in section 3, but what I'm saying is that the MUST NOT in the text I cited contradicts this text (if you interpret the MUST NOT strictly but maybe I'm to strict here). So to be more clear one could say: \r\n\r\n\"... MUST NOT send DATAGRAM frames until it has received the max_datagram_frame_size transport parameter with a non-zero value in the handshake, or a previous handshake if 0-RTT is used.\"\r\n\r\nRegarding the server not supporting datagram in 0-RTT anymore, my assumption was that if the server does not have any state if datagram was used but does not support datagram anymore for some reason, it would receive a 0-RTT with a datagram and probably close the connection based on this text:\r\n\r\n\"An endpoint that receives a DATAGRAM frame when it has not indicated support via the transport parameter MUST terminate the connection with an error of type PROTOCOL_VIOLATION.\"\r\n\r\nI guess you are saying if 0-RTT and datagram is used the server MUST remember that datagram was negotiated?\r\n\r\nHowever, there is also this text:\r\n\r\n\"If a client stores the value of the max_datagram_frame_size transport parameter with their 0-RTT state, they MUST validate that the new value of the max_datagram_frame_size transport parameter sent by the server in the handshake is greater or equal to the stored value; if not, the client MUST terminate the connection with error PROTOCOL_VIOLATION.\"\r\n\r\nSo this would mean larger datagram are accepted in 0-RTT but then if the server indicates a smaller value for 1-RTT, the connection needs to be terminated? Why?\r\n\r\nAlso if datagram was used in the previous connection, then 0-RTT is used without datagrams, the server can still not indicate in the handshake that is not supporting datagram anymore?\r\n\r\nAll I'm saying is that these things could be further clarified to avoid any doubt.",
          "createdAt": "2021-10-07T08:01:39Z",
          "updatedAt": "2021-10-07T08:01:39Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I know that this is explained in section 3, but what I'm saying is that the MUST NOT in the text I cited contradicts this text (if you interpret the MUST NOT strictly but maybe I'm to strict here). So to be more clear one could say:\r\n> \r\n> \"... MUST NOT send DATAGRAM frames until it has received the max_datagram_frame_size transport parameter with a non-zero value in the handshake, or a previous handshake if 0-RTT is used.\"\r\n\r\nAdding \"or a previous handshake if 0-RTT is used\" is fine by me.\r\n\r\n> Regarding the server not supporting datagram in 0-RTT anymore, my assumption was that if the server does not have any state if datagram was used but does not support datagram anymore for some reason, it would receive a 0-RTT with a datagram\r\n\r\nYour assumption is incorrect. If servers used to support datagram and they accept 0-RTT, they must also support datagram in the new connection. That's spelled out here:\r\n\r\n```\r\n   When servers decide\r\n   to accept 0-RTT data, they MUST send a max_datagram_frame_size\r\n   transport parameter greater or equal to the value they sent to the\r\n   client in the connection where they sent them the NewSessionTicket\r\n   message.\r\n```\r\n\r\n> All I'm saying is that these things could be further clarified to avoid any doubt.\r\n\r\nClarifications are always good. Can you send a PR?",
          "createdAt": "2021-10-07T19:05:37Z",
          "updatedAt": "2021-10-07T19:05:37Z"
        }
      ]
    },
    {
      "number": 64,
      "id": "I_kwDODoD7Ms48uiPh",
      "title": "What happens if an application wants to send a too large datagram?",
      "url": "https://github.com/quicwg/datagram/issues/64",
      "state": "CLOSED",
      "author": "mirjak",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Section 5 says:\r\n\u201cDATAGRAM frames cannot be fragmented; therefore, application protocols need to handle cases where the maximum datagram size is limited by other factors.\u201c\r\n \r\nHowever, this section does not say what the transport should do if the application tries to send a too large datagram. Is that datagram just dropped, eventually indicating an error to the application? Would be good to explicitly spell this out.",
      "createdAt": "2021-10-06T17:34:42Z",
      "updatedAt": "2022-01-14T18:21:15Z",
      "closedAt": "2022-01-14T18:21:15Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this will just be dropped, like the text describes for flow control on congestion control reasons.\r\n\r\nThe signaling to the application will be API specific for this case. I think we can't say anything normative about this, but we could suggest that implementations consider how this case would be signaled to applications.",
          "createdAt": "2021-10-06T20:03:37Z",
          "updatedAt": "2021-10-06T20:03:37Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "body": "I don't like the \"just drop it\" answer; while datagrams are inherently unreliable, that doesn't mean an application expects a message it sends to not even attempt to be delivered.  \"Need to handle\" basically means applications need to do their own PMTUD implementation atop DATAGRAMs, since even querying an API only tells you one hop.\r\n\r\nThe DATAGRAM capsule type means that an arbitrarily large datagram can be transported, but loses the benefit of unreliable, out-of-order delivery.  I had previously suggested that we could optionally define a Datagram unidirectional stream type, which would allow for reliable out-of-order delivery of larger-than-MTU payloads.\r\n\r\nIf a datagram being transported is too large for a DATAGRAM frame, perhaps some other method SHOULD be used?",
          "createdAt": "2021-10-06T20:32:41Z",
          "updatedAt": "2021-10-06T20:32:41Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@MikeBishop for H3 datagrams, then, it could fall back to sending a capsule over the stream itself, assuming the application layer knew that the datagram was dropped or too large. I do think for the QUIC datagram layer itself, it can only drop and notify if the application tries to send something too large, and it's up to the application protocol to handle it.",
          "createdAt": "2021-10-06T20:36:57Z",
          "updatedAt": "2021-10-06T20:36:57Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "body": "Ah, sorry -- wrong repo!  You're correct -- at the QUIC layer, that's all you can do.",
          "createdAt": "2021-10-06T20:44:26Z",
          "updatedAt": "2021-10-06T20:44:26Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "I think a lot of this comes down to an implementation decision. In one sense there is similarity with stream data whn an application tries to write more bytes than the flow control would allow. How that is handles is a choice - you could send some of the bytes (up to the flow control limit) or reject them all and tell the application this. A library might have an API that can returncurrent capacity and expect the application to chunk writes. The list is long and it depends on lots of things we won't agree on.\r\n\r\nSpecifically for datagram, the OP question can be rephrased as what should the transport do about something that it by definition cannot do. But really its an implementation choice. In mine I expose the maximum size allowed. If an application tries to give me something bigger I reject the operation. I don't drop the datagram, I never accepted it. The application is trying something that will never logically work and there's probably a host of application-layer reasons or ways to deal with it. Mike's comments speak to that but there is not things to say here in this specification IMO",
          "createdAt": "2021-10-06T21:17:46Z",
          "updatedAt": "2021-10-06T21:17:46Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "NONE",
          "body": "Actually I think for datagrams, sending only some of the data should not be an option. I think for datagrams the implicit contract is that the application always gets the whole datagram or nothing. So that's probably something to spell out.",
          "createdAt": "2021-10-07T07:35:58Z",
          "updatedAt": "2021-10-07T07:35:58Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I seriously considered adding a line to the draft that prohibits truncation, but looking into it I realized that this document doesn't define an API contract for sending and receiving datagrams, so truncation is out of scope. Also, I could imagine there exists an application out there that does want truncation, so there's no reason to ban this in all implementations and applications. All existing implementations already the right thing for their applications today, so adding text doesn't help there either. I'm closing this editorial issue with no action so we can move things forward.",
          "createdAt": "2022-01-14T18:21:15Z",
          "updatedAt": "2022-01-14T18:21:15Z"
        }
      ]
    },
    {
      "number": 65,
      "id": "I_kwDODoD7Ms4_5tpc",
      "title": "consequence of not protecting DATAGRAM with 0-RTT or 1-RTT",
      "url": "https://github.com/quicwg/datagram/issues/65",
      "state": "CLOSED",
      "author": "zaheduzzaman",
      "authorAssociation": "NONE",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "Section 5: says\r\n\r\nDATAGRAM frames MUST be protected with either 0-RTT or 1-RTT keys.\r\n\r\nI would suggest to add the \"otherwise what happens\" part. One/two like explanation will be helpful and I think that will improve the understanding of this requirement.",
      "createdAt": "2021-12-06T12:26:12Z",
      "updatedAt": "2021-12-07T16:00:21Z",
      "closedAt": "2021-12-07T16:00:21Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Almost all QUIC frame types are like this. I would suggest saying \"Like STREAM frames, ...\" to make this obvious for the rationale.",
          "createdAt": "2021-12-06T17:50:35Z",
          "updatedAt": "2021-12-06T17:50:35Z"
        }
      ]
    },
    {
      "number": 66,
      "id": "I_kwDODoD7Ms4_5uOc",
      "title": "explain the recommendation pattern for supporting coexistence of multiple datagram flows",
      "url": "https://github.com/quicwg/datagram/issues/66",
      "state": "CLOSED",
      "author": "zaheduzzaman",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Section 5.1: says\r\n\r\n  If the application needs to support the coexistence of multiple flows of datagrams, one recommended pattern is to use a variable-length integer at the beginning of the Datagram Data field.\r\n\r\nIt would be nicer if we explain why we are recommending that pattern. Some lines to capture the valuable discussion on this would be valuable.",
      "createdAt": "2021-12-06T12:28:55Z",
      "updatedAt": "2021-12-07T23:03:18Z",
      "closedAt": "2021-12-07T23:03:18Z",
      "comments": []
    },
    {
      "number": 67,
      "id": "I_kwDODoD7Ms4_5_Z4",
      "title": "Congestion related information to the application",
      "url": "https://github.com/quicwg/datagram/issues/67",
      "state": "CLOSED",
      "author": "zaheduzzaman",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Real-time interactive media applications likely be one of the biggest consumer of the QUIC Datagram where application can have both reliable and unreliable data to send.  Usually this kind of applications have rate controller which controls the media rate and it is possible to completely ignore the congestion control used underneath and develop something only looking a the sender queue. In that case, the QUIC datagram implementations must to provide such information to the applications. However, from my experience and my chat with other real-time application folks on this (see scream and nada algorithms from RMCAT working group), this will be not optimal to only look at the sender queue and will require congestion events ( such as loss, ECN) to be propagated to the application to make the rate controller work efficiently. The current text talks only about implementations MAY send sender buffer or drop at sender information to the application which does not seems sufficient here as this will lead to mediocre performance of the media application. \r\n\r\nHere my suggestion would be to amend that the implementations always provide sender queue (and/or congestion related information to the application) or that the application the have possibility to query for those information. It is also worth saying that media applications need to think about their application need and tune their rate controller that they don't expect what ever congestion controller used for unreliable traffic is media aware. However, I don't think section 5.4 need to details the accurate behavior of the application's media rate controller. \r\n",
      "createdAt": "2021-12-06T13:40:54Z",
      "updatedAt": "2021-12-09T09:56:52Z",
      "closedAt": "2021-12-08T18:04:56Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Section 5.2 indicates that QUIC may notify the application when the datagram is ACKed, and Section 5.4 says QUIC may notify the application when the datagram cannot be sent due to congestion control.\r\n\r\nAs far as I can see, those are the only concrete notifications that are appropriate that are specific to the DATAGRAM frame.\r\n\r\nI can absolutely see how a media streaming application may want to get other notifications about loss detection and ECN in general, but those seem to be generic features of QUIC notifying the application, and are not specific to this particular frame type. As such, I feel that this belongs in other future documents.",
          "createdAt": "2021-12-06T18:04:02Z",
          "updatedAt": "2021-12-06T18:04:02Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 to what @tfpauly said. We've built a real-time media application over QUIC DATAGRAMs at Google, relying only on a notification when a datagram is ACKed or considered lost. Implementations are free to share more information with the application, but we shouldn't recommend an unimplemented technique that might not even work.",
          "createdAt": "2021-12-07T00:07:10Z",
          "updatedAt": "2021-12-07T00:07:10Z"
        },
        {
          "author": "IngJohEricsson",
          "authorAssociation": "NONE",
          "body": "I have some experience with SCReAM, where it is definitely necessary to notify the application level about congestion.. The result is otherwise that a queue will build up on the sender side. \r\nThis is perhaps not an issue if the delay budget for the application is measured in seconds, but if the goal is low latency streaming, then I would say that it is necessary. \r\nIf one try and distill the bare necessities out of SCReAM then one can implement something that signals the necessary target bitrate reduction up to the application (video encoder). \r\nThis signal is transmitted upon each new congestion event and is simply a metric that indicates the expected fractional decrease of the output rate by the QUIC connection. This is given by how much the congestion window decreases and the expected reduction in RTT. This is a relatively  exact metric with L4S as the RTT is essentially unchanged. With loss based and ECN it becomes more of an approximation. \r\n",
          "createdAt": "2021-12-08T06:55:02Z",
          "updatedAt": "2021-12-08T06:55:02Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Congestion control state is a property of the connection, not isolated to this extension or of a particular use of this extension. It seems fine to me to let implementations figure out what is sufficient information to applications. If there's something common worth detailing more, that can be documented elsewhere.",
          "createdAt": "2021-12-08T12:31:14Z",
          "updatedAt": "2021-12-08T12:31:14Z"
        },
        {
          "author": "zaheduzzaman",
          "authorAssociation": "NONE",
          "body": "@DavidSchinazi , then you have experience of real-time application over QUIC DATAGRAM. if I understand it correctly, you needed the DATAGRAM ACK information, right?\r\n\r\n@tfpauly I can agree that those two notifications are the relevant to DATAGRAM frames. However, from our work on RMCAT working group, I am concerned that application developers will need more information for a proper rate controlled application and if the implementations are not aware of that if might be hard to get such information. I just hope that application developers will not just run media over QUIC DATAGRAM and expect things to work, so that they consider this in their design.   ",
          "createdAt": "2021-12-08T16:01:45Z",
          "updatedAt": "2021-12-08T16:01:45Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I expect that documents that define media apps over QUIC will explain what signals they need. Apps won't deploy without those new documents. This isn't in scope for this one frame. ",
          "createdAt": "2021-12-08T16:06:27Z",
          "updatedAt": "2021-12-08T16:06:27Z"
        },
        {
          "author": "zaheduzzaman",
          "authorAssociation": "NONE",
          "body": "Lets go with that expectation.",
          "createdAt": "2021-12-08T16:29:42Z",
          "updatedAt": "2021-12-08T16:29:42Z"
        },
        {
          "author": "IngJohEricsson",
          "authorAssociation": "NONE",
          "body": "OK, sounds good to me",
          "createdAt": "2021-12-09T09:56:52Z",
          "updatedAt": "2021-12-09T09:56:52Z"
        }
      ]
    },
    {
      "number": 68,
      "id": "I_kwDODoD7Ms4_6CDQ",
      "title": "Bandwidth distribution to media and non-media traffic - applicablity statements",
      "url": "https://github.com/quicwg/datagram/issues/68",
      "state": "CLOSED",
      "author": "zaheduzzaman",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "There is another matter with available bandwidth distribution to media and non-media bulk traffic. if the application have these two sort of traffic mix on the same QUIC connection then the bulk traffic streaming can chock the latency sensitive media/ game control traffic unless there is priority applied or bandwidth distribution is provisioned (fixed for media/bulk traffic). The current draft does not talk about it. As this traffic mix is application dependent I think that is fine to leave out the details of the how to do the distribution and what priority to use. However, This is something the user of the QUIC should consider. This piece of information will be very important hence we may want to add this to applicability statements of QUIC datagram usage. I would like to know what others think about it? and where such applicability statements should go for QUIC extensions when the applicability draft is already published?  ",
      "createdAt": "2021-12-06T13:52:20Z",
      "updatedAt": "2021-12-08T15:31:38Z",
      "closedAt": "2021-12-08T15:31:38Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't feel like this is in scope for this document. The use of the frame by various applications is up to the definition of the applications, not the transport.",
          "createdAt": "2021-12-06T17:58:11Z",
          "updatedAt": "2021-12-06T17:58:11Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 to what @tfpauly said. It's too early to tell what this extension will be used for, so a generic applicability statement is not going to be useful. The applications will figure out what works best for them when they have running code.",
          "createdAt": "2021-12-07T00:03:56Z",
          "updatedAt": "2021-12-07T00:03:56Z"
        },
        {
          "author": "IngJohEricsson",
          "authorAssociation": "NONE",
          "body": "OK, perhaps not necessary in spec text, I do however expect some headache here in line with what Zahed mentions above. It is perhaps not necessary to specify code to handle this. \r\nBut it can be good with some kind of mention of the possible scheduling  issues between applications that are source limited (e.g low latency video) and those who are not (large file transfers) when they share the same QUIC connection.",
          "createdAt": "2021-12-08T07:00:46Z",
          "updatedAt": "2021-12-08T07:00:46Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Such considerations apply to QUIC streams too, and those are not mentioned in RFC 9000.\r\n\r\nMy suggestion would be to defer on saying anything now because it might later be found out to be unproven or unsound.\r\nApplications themselves have n stake in making their use of QUIC work well, delivering of resources against their own determination of timeliness or service. Since the definition of those are outside the scope of this document, so is applicability advice at this stage. There's always opportunity to make an I-D that updates draft-ietf-quic-applicability should common patterns and advice be found in practice.",
          "createdAt": "2021-12-08T12:23:27Z",
          "updatedAt": "2021-12-08T12:23:27Z"
        },
        {
          "author": "zaheduzzaman",
          "authorAssociation": "NONE",
          "body": "OK this is I think fine to leave out of the document for now and have the recommendations when we have more experience of running media over QUIC.",
          "createdAt": "2021-12-08T15:31:38Z",
          "updatedAt": "2021-12-08T15:31:38Z"
        }
      ]
    },
    {
      "number": 81,
      "id": "I_kwDODoD7Ms5GPESG",
      "title": "RFC Editor comment 1",
      "url": "https://github.com/quicwg/datagram/issues/81",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "auth48"
      ],
      "body": "Please insert any keywords (beyond those that appear in \nthe title) for use on https://www.rfc-editor.org/search.\n",
      "createdAt": "2022-03-23T16:20:51Z",
      "updatedAt": "2022-04-03T18:23:36Z",
      "closedAt": "2022-04-03T18:23:36Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I propose \"quic\" and \"datagram\"",
          "createdAt": "2022-03-23T16:39:20Z",
          "updatedAt": "2022-03-23T16:39:20Z"
        }
      ]
    },
    {
      "number": 82,
      "id": "I_kwDODoD7Ms5GPESr",
      "title": "RFC Editor comment 2",
      "url": "https://github.com/quicwg/datagram/issues/82",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "auth48"
      ],
      "body": "Please review whether the \"type\" attribute should be set for\nthe sourcecode element in the XML file. If the current list of preferred\nvalues for \"type\"\n(https://www.rfc-editor.org/materials/sourcecode-types.txt) does not\ncontain an applicable type, then feel free to suggest a new one.\nAlso, it is acceptable to leave the \"type\" attribute not set.  ",
      "createdAt": "2022-03-23T16:20:52Z",
      "updatedAt": "2022-04-03T18:23:36Z",
      "closedAt": "2022-04-03T18:23:36Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looking at RFC 9000, these aren't source code, but are artwork, and without a type:\r\n\r\n```\r\n          <artwork name=\"\" type=\"\" align=\"left\" alt=\"\" pn=\"section-19.8-5.1\">\r\nSTREAM Frame {\r\n  Type (i) = 0x08..0x0f,\r\n  Stream ID (i),\r\n  [Offset (i)],\r\n  [Length (i)],\r\n  Stream Data (..),\r\n}\r\n</artwork>\r\n```\r\n\r\nI'd suggest matching that.\r\n",
          "createdAt": "2022-03-23T16:58:14Z",
          "updatedAt": "2022-03-23T16:58:14Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Matching RFC9000 SGTM",
          "createdAt": "2022-03-23T17:02:06Z",
          "updatedAt": "2022-03-23T17:02:06Z"
        }
      ]
    },
    {
      "number": 83,
      "id": "I_kwDODoD7Ms5GPETF",
      "title": "For clarity, may this sentence be updated as follows?\n\nOriginal (comment 3)",
      "url": "https://github.com/quicwg/datagram/issues/83",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "auth48"
      ],
      "body": "For clarity, may this sentence be updated as follows?\n\nOriginal:\n\n       Identifiers used to multiplex different kinds of datagrams, or flows\n       of datagrams, are the responsibility of the application protocol\n       running over QUIC to define.  \n\nPerhaps:\n   Defining the identifiers used to multiplex different kinds of\n   datagrams or flows of datagrams is the responsibility of the\n   application protocol running over QUIC. \n",
      "createdAt": "2022-03-23T16:20:54Z",
      "updatedAt": "2022-04-03T18:23:36Z",
      "closedAt": "2022-04-03T18:23:36Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "SGTM",
          "createdAt": "2022-03-23T16:37:08Z",
          "updatedAt": "2022-03-23T16:37:08Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed, this looks fine to me.",
          "createdAt": "2022-03-23T16:53:07Z",
          "updatedAt": "2022-03-23T16:53:07Z"
        }
      ]
    },
    {
      "number": 84,
      "id": "I_kwDODoD7Ms5GPETf",
      "title": "Would you like to change \"and\" to \"-\" here?\n\nCurrent (comment 4)",
      "url": "https://github.com/quicwg/datagram/issues/84",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "auth48"
      ],
      "body": "Would you like to change \"and\" to \"-\" here?\n\nCurrent: 0x30 and 0x31\nPerhaps: 0x30-0x31\n\nThe latter would match the IANA registry and would\nmatch how 0x12-0x13 (for example) appears in RFC 9000\n(https://www.rfc-editor.org/rfc/rfc9000.html#section-12.4).\n",
      "createdAt": "2022-03-23T16:20:55Z",
      "updatedAt": "2022-04-03T18:23:36Z",
      "closedAt": "2022-04-03T18:23:36Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, we should change this to match the IANA registry",
          "createdAt": "2022-03-23T16:53:30Z",
          "updatedAt": "2022-03-23T16:53:30Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "SGTM",
          "createdAt": "2022-03-23T17:02:28Z",
          "updatedAt": "2022-03-23T17:02:28Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 10,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE0ODY5NjY5",
      "title": "Change TP to max_datagram_payload_size",
      "url": "https://github.com/quicwg/datagram/pull/10",
      "state": "CLOSED",
      "author": "nibanks",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This PR changes the TP from `max_datagram_frame_size` to `max_datagram_payload_size`.\r\n\r\nFixes #3.",
      "createdAt": "2020-05-07T19:12:54Z",
      "updatedAt": "2021-07-12T03:09:52Z",
      "baseRepository": "quicwg/datagram",
      "baseRefName": "main",
      "baseRefOid": "5fe5d4edd3efe42b74e0bba1489c0feb9fcef9c6",
      "headRepository": "nibanks/datagram",
      "headRefName": "pr/max-datagram-payload-size",
      "headRefOid": "ad8ed8f392384b54bf04fb92931f919d51108c28",
      "closedAt": "2021-07-12T03:09:52Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "@DavidSchinazi sure. I'll make this PR just about changing to payload size then.",
          "createdAt": "2020-05-08T01:26:23Z",
          "updatedAt": "2020-05-08T01:26:23Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I believe this is now outdated, and superseded by more recent PRs",
          "createdAt": "2021-07-12T03:09:52Z",
          "updatedAt": "2021-07-12T03:09:52Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3OTM3Mjkw",
          "commit": {
            "abbreviatedOid": "a7cd6b2"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "This PR is conflating two different topics. \r\n1) is the transport parameter unidirectional or bidirectional?\r\n2) does the transport parameter cover the frame size or payload size?\r\n\r\nCould you please split this into two PRs?",
          "createdAt": "2020-05-08T01:18:13Z",
          "updatedAt": "2020-05-08T01:18:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 11,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE1Mjc5Njgx",
      "title": "Make the TP Unidirectional",
      "url": "https://github.com/quicwg/datagram/pull/11",
      "state": "MERGED",
      "author": "nibanks",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Defines the transport parameter as a unidirectional configuration.\r\n\r\nFixes #7.",
      "createdAt": "2020-05-08T15:02:50Z",
      "updatedAt": "2020-05-08T22:32:19Z",
      "baseRepository": "quicwg/datagram",
      "baseRefName": "master",
      "baseRefOid": "40181bac148834470b79e7e9e371f8cee1e0dc2c",
      "headRepository": "nibanks/datagram",
      "headRefName": "pr/unidirectional",
      "headRefOid": "f03a1e359cc83352c1e9f98148fb960a83e16778",
      "closedAt": "2020-05-08T22:32:05Z",
      "mergedAt": "2020-05-08T22:32:04Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "5fe5d4edd3efe42b74e0bba1489c0feb9fcef9c6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4NDA3NjA1",
          "commit": {
            "abbreviatedOid": "28715b5"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-08T17:44:49Z",
          "updatedAt": "2020-05-08T17:44:49Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4NTU4MDcx",
          "commit": {
            "abbreviatedOid": "28715b5"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-08T22:17:24Z",
          "updatedAt": "2020-05-08T22:17:29Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "nit: `s/for a protocol/for an application protocol/`",
              "createdAt": "2020-05-08T22:17:24Z",
              "updatedAt": "2020-05-08T22:27:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4NTU4NjMx",
          "commit": {
            "abbreviatedOid": "28715b5"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-08T22:19:03Z",
          "updatedAt": "2020-05-08T22:19:04Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Actually we can make this normative:\r\n\r\n`Application protocols that use DATAGRAM frames MAY choose to only negotiate and use them in a single direction.`",
              "createdAt": "2020-05-08T22:19:03Z",
              "updatedAt": "2020-05-08T22:27:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4NTYxMTYz",
          "commit": {
            "abbreviatedOid": "28715b5"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-08T22:26:32Z",
          "updatedAt": "2020-05-08T22:26:32Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Sure. Let me update that now.",
              "createdAt": "2020-05-08T22:26:32Z",
              "updatedAt": "2020-05-08T22:27:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4NTYyNzgx",
          "commit": {
            "abbreviatedOid": "f03a1e3"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-08T22:31:36Z",
          "updatedAt": "2020-05-08T22:31:37Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Thanks!",
              "createdAt": "2020-05-08T22:31:36Z",
              "updatedAt": "2020-05-08T22:31:37Z"
            }
          ]
        }
      ]
    },
    {
      "number": 14,
      "id": "MDExOlB1bGxSZXF1ZXN0NTIwMjAyMTI4",
      "title": "Change recommendation for max size to 65535",
      "url": "https://github.com/quicwg/datagram/pull/14",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #13",
      "createdAt": "2020-11-12T22:43:40Z",
      "updatedAt": "2020-11-13T03:32:21Z",
      "baseRepository": "quicwg/datagram",
      "baseRefName": "master",
      "baseRefOid": "5fe5d4edd3efe42b74e0bba1489c0feb9fcef9c6",
      "headRepository": "quicwg/datagram",
      "headRefName": "tfpauly-patch-1",
      "headRefOid": "ac6d215a51288b390292e1be25c0c1c329d0baeb",
      "closedAt": "2020-11-13T03:32:20Z",
      "mergedAt": "2020-11-13T03:32:20Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "42f25fcf1f7f80cdeadba1ed3340d06262078dbc"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI5NTY1OTY1",
          "commit": {
            "abbreviatedOid": "ac6d215"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-12T22:51:39Z",
          "updatedAt": "2020-11-12T22:51:39Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI5NTc4NTk0",
          "commit": {
            "abbreviatedOid": "ac6d215"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-12T23:17:42Z",
          "updatedAt": "2020-11-12T23:17:42Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI5NTc5MzM2",
          "commit": {
            "abbreviatedOid": "ac6d215"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-12T23:19:22Z",
          "updatedAt": "2020-11-12T23:19:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 17,
      "id": "MDExOlB1bGxSZXF1ZXN0NTg0MzU0NzA4",
      "title": "Reword lowercase \"may\"s",
      "url": "https://github.com/quicwg/datagram/pull/17",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "Closes #4",
      "createdAt": "2021-03-03T23:33:24Z",
      "updatedAt": "2021-03-04T14:34:33Z",
      "baseRepository": "quicwg/datagram",
      "baseRefName": "master",
      "baseRefOid": "42f25fcf1f7f80cdeadba1ed3340d06262078dbc",
      "headRepository": "quicwg/datagram",
      "headRefName": "tfpauly-patch-1",
      "headRefOid": "005029da2ad99428fb9c5684edf5c2a7e5e5b16f",
      "closedAt": "2021-03-04T14:34:33Z",
      "mergedAt": "2021-03-04T14:34:33Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "bc4f55649cdb53c0d590a4b63dbf36d68adcd913"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAzNDcxNDMx",
          "commit": {
            "abbreviatedOid": "005029d"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-03T23:42:51Z",
          "updatedAt": "2021-03-03T23:42:51Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAzNTkyNzM2",
          "commit": {
            "abbreviatedOid": "005029d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2021-03-04T01:03:30Z",
          "updatedAt": "2021-03-04T01:03:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 18,
      "id": "MDExOlB1bGxSZXF1ZXN0NTg0ODY0NDQ2",
      "title": "Note about pacing",
      "url": "https://github.com/quicwg/datagram/pull/18",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "Warn against the pathological case of dropping packets due to pacing. Closes #16",
      "createdAt": "2021-03-04T14:46:41Z",
      "updatedAt": "2021-03-04T18:12:12Z",
      "baseRepository": "quicwg/datagram",
      "baseRefName": "master",
      "baseRefOid": "bc4f55649cdb53c0d590a4b63dbf36d68adcd913",
      "headRepository": "quicwg/datagram",
      "headRefName": "tfpauly-patch-1",
      "headRefOid": "c83cd94d6d8281a2d2efaabaa080bf4a96ca8c10",
      "closedAt": "2021-03-04T18:12:11Z",
      "mergedAt": "2021-03-04T18:12:11Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "6dec1591e44a54fc1ed6f1c6f43c7196b30d6acc"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA0MzA5NzIw",
          "commit": {
            "abbreviatedOid": "c83cd94"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2021-03-04T16:39:07Z",
          "updatedAt": "2021-03-04T16:39:07Z",
          "comments": []
        }
      ]
    },
    {
      "number": 19,
      "id": "MDExOlB1bGxSZXF1ZXN0NjA2MTQ0MjU4",
      "title": "Clarify meaning of 0 in the datagram transport parameter",
      "url": "https://github.com/quicwg/datagram/pull/19",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Clarify meaning of 0 in the datagram transport parameter, based on the discussion at IETF 110. This follows one of the suggestions to have 0 mean no datagrams, and > 0 mean support for datagrams. This should be a non-breaking change with existing implementations.\r\n\r\nCloses #3 ",
      "createdAt": "2021-03-31T18:31:58Z",
      "updatedAt": "2021-07-06T04:36:01Z",
      "baseRepository": "quicwg/datagram",
      "baseRefName": "main",
      "baseRefOid": "6dec1591e44a54fc1ed6f1c6f43c7196b30d6acc",
      "headRepository": "quicwg/datagram",
      "headRefName": "tfpauly-patch-1",
      "headRefOid": "33f1a6669e5c1c0b0a00a611dd7bfa038678f7b8",
      "closedAt": "2021-07-06T04:36:00Z",
      "mergedAt": "2021-07-06T04:35:59Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "0d91c89e3fb64a53d54ff934822cee08e2ee4ded"
      },
      "comments": [
        {
          "author": "Ralith",
          "authorAssociation": "NONE",
          "body": "This change is very surprising. Why not take the approach that was discussed in the issue, wherein the limit describes the *payload* size, and presence of the transport parameter indicates extension support? It's not useful to have a bunch of ill-formed possibilities where the limit describes the frame size but is smaller than needed to encode the frame.\r\n\r\nSee also https://github.com/tfpauly/draft-pauly-quic-datagram/pull/31.",
          "createdAt": "2021-03-31T18:55:06Z",
          "updatedAt": "2021-03-31T18:57:13Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@Ralith this is based on the WG discussion, minuted here: https://github.com/quicwg/wg-materials/blob/main/ietf110/minutes.md",
          "createdAt": "2021-03-31T20:28:50Z",
          "updatedAt": "2021-03-31T20:28:50Z"
        },
        {
          "author": "Ralith",
          "authorAssociation": "NONE",
          "body": "So it comes down to preserving the weird semantics nobody wants because renumbering the TP is aesthetically unappealing? That seems like a shame. Unless saying \"I support it, but you can't send it\" is actually useful somehow?",
          "createdAt": "2021-03-31T20:58:29Z",
          "updatedAt": "2021-03-31T20:58:29Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI1NjEwNTQz",
          "commit": {
            "abbreviatedOid": "a6d4034"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-31T18:44:58Z",
          "updatedAt": "2021-03-31T18:44:58Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI1NjM2Njc1",
          "commit": {
            "abbreviatedOid": "a6d4034"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-31T19:17:45Z",
          "updatedAt": "2021-03-31T19:18:20Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "```suggestion\r\nreceive such frames on this connection.\r\n```",
              "createdAt": "2021-03-31T19:17:45Z",
              "updatedAt": "2021-03-31T20:28:57Z"
            }
          ]
        }
      ]
    },
    {
      "number": 20,
      "id": "MDExOlB1bGxSZXF1ZXN0NjA2MTc2Mzkx",
      "title": "Explain the lack of flow IDs, and suggest a pattern",
      "url": "https://github.com/quicwg/datagram/pull/20",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #6",
      "createdAt": "2021-03-31T18:55:19Z",
      "updatedAt": "2021-07-12T02:53:03Z",
      "baseRepository": "quicwg/datagram",
      "baseRefName": "main",
      "baseRefOid": "6dec1591e44a54fc1ed6f1c6f43c7196b30d6acc",
      "headRepository": "quicwg/datagram",
      "headRefName": "tfpauly-patch-2",
      "headRefOid": "4cdafa1f8230def6db6b5446ee81e69dffd295ab",
      "closedAt": "2021-07-12T02:53:02Z",
      "mergedAt": "2021-07-12T02:53:02Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "a74ac46449ab0226067e19c6bb7b8de9d9ba2d6b"
      },
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "NONE",
          "body": "I would like this section to say something about priorities, as emerged in the issue. Something to the effect of:\r\n\r\n\"QUIC Implementations SHOULD present an API to applications to assign relative priorities to DATAGRAM frames with respect to each other and to QUIC streams. This can be done by the API conceptually assigning DATAGRAM frames to an existing QUIC stream and inheriting its priority, or assigning a priority in the DATAGRAM send API itself.\"",
          "createdAt": "2021-06-23T16:48:27Z",
          "updatedAt": "2021-06-23T16:48:27Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "the first sentence of @martinduke's suggestion sounds ok. I don't like the second one much (sorry).\r\n\r\nedit: clarification - the first sentence is very much like RFC 9000's \"A QUIC implementation SHOULD provide ways in which an application can indicate the relative priority of streams\"",
          "createdAt": "2021-06-23T17:54:14Z",
          "updatedAt": "2021-06-23T17:55:45Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "NONE",
          "body": "> \r\n> \r\n> the first sentence of @martinduke's suggestion sounds ok. I don't like the second one much (sorry).\r\n> \r\n> edit: clarification - the first sentence is very much like RFC 9000's \"A QUIC implementation SHOULD provide ways in which an application can indicate the relative priority of streams\"\r\n\r\nI'm not married to the second sentence.",
          "createdAt": "2021-06-23T17:56:19Z",
          "updatedAt": "2021-06-23T17:56:19Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Piling on to agree here: I'm OK with adding the first sentence, though I think the second one is too specific so I'd prefer the second sentence wasn't added",
          "createdAt": "2021-06-23T22:02:32Z",
          "updatedAt": "2021-06-23T22:02:32Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Added the first sentence about priorities. Please check!",
          "createdAt": "2021-07-06T23:48:53Z",
          "updatedAt": "2021-07-06T23:48:53Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI1NjIxMzk4",
          "commit": {
            "abbreviatedOid": "76d135a"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-31T18:58:16Z",
          "updatedAt": "2021-03-31T18:58:16Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "I assume H3 datagram spec also references back to this one? Does it make sense to have a circular reference? I know some in the IETF discussion wanted this text, but I'm personally fine with out this last paragraph.",
              "createdAt": "2021-03-31T18:58:16Z",
              "updatedAt": "2021-03-31T18:58:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI1NjIxNTEx",
          "commit": {
            "abbreviatedOid": "76d135a"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-31T18:58:24Z",
          "updatedAt": "2021-03-31T18:58:24Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI1NjI4OTY3",
          "commit": {
            "abbreviatedOid": "76d135a"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-31T19:07:56Z",
          "updatedAt": "2021-03-31T19:07:56Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Circular references are common and fine",
              "createdAt": "2021-03-31T19:07:56Z",
              "updatedAt": "2021-03-31T19:07:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI1NjMwODI2",
          "commit": {
            "abbreviatedOid": "76d135a"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-31T19:10:18Z",
          "updatedAt": "2021-03-31T19:10:18Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI1NjkxNTY4",
          "commit": {
            "abbreviatedOid": "76d135a"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-31T20:29:46Z",
          "updatedAt": "2021-03-31T20:29:46Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Yup, this is a non-normative reference; H3 datagram will have a normative reference.",
              "createdAt": "2021-03-31T20:29:46Z",
              "updatedAt": "2021-03-31T20:29:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI1NjkyNzQx",
          "commit": {
            "abbreviatedOid": "76d135a"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-31T20:31:18Z",
          "updatedAt": "2021-03-31T20:31:18Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Agreed, though FWIW circular normative references are OK - they just require simultaneous publication.",
              "createdAt": "2021-03-31T20:31:18Z",
              "updatedAt": "2021-03-31T20:31:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI1NzI0MTI5",
          "commit": {
            "abbreviatedOid": "76d135a"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-31T21:13:54Z",
          "updatedAt": "2021-03-31T21:13:55Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "I'm not too bothered by a circular reference but I don't think it adds much. The wire format is simple. The main complexity of the H3 draft comes from how the flow IDs meld with HTTP semantics. So if you're going to reference it then be more specific about why, or just don't bother IMO.\r\n\r\nAnd if you are going to reference it, let's use the MASQUE edited draft ",
              "createdAt": "2021-03-31T21:13:54Z",
              "updatedAt": "2021-03-31T21:13:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU3MzA5NjQ2",
          "commit": {
            "abbreviatedOid": "76d135a"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-11T23:30:58Z",
          "updatedAt": "2021-05-11T23:30:58Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Given some of the churn in H3 DGRAM, how about we extract this third paragraph into another issue/PR that we can sit on while we land the other changes?",
              "createdAt": "2021-05-11T23:30:58Z",
              "updatedAt": "2021-05-11T23:30:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAwNDYzOTQw",
          "commit": {
            "abbreviatedOid": "0bd9bb8"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-06T23:49:14Z",
          "updatedAt": "2021-07-06T23:49:15Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "@LPardue removed the specific H3 datagram reference; that OK?",
              "createdAt": "2021-07-06T23:49:14Z",
              "updatedAt": "2021-07-06T23:49:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAwNDY5MDQ2",
          "commit": {
            "abbreviatedOid": "0bd9bb8"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-07T00:02:44Z",
          "updatedAt": "2021-07-07T00:02:45Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "\"differentiate between different\" seems kind of redundant. I tried penning a suggestion for this sentence but it didn't seem to read any better",
              "createdAt": "2021-07-07T00:02:45Z",
              "updatedAt": "2021-07-07T00:02:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAwNDY5MjY0",
          "commit": {
            "abbreviatedOid": "0bd9bb8"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "I made a grammatical nit, but in the absence being able to make a firm suggestion, this LGTM.",
          "createdAt": "2021-07-07T00:03:23Z",
          "updatedAt": "2021-07-07T00:03:23Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAwNDY5Mzg3",
          "commit": {
            "abbreviatedOid": "0bd9bb8"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-07T00:03:39Z",
          "updatedAt": "2021-07-07T00:03:39Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "yep!",
              "createdAt": "2021-07-07T00:03:39Z",
              "updatedAt": "2021-07-07T00:03:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAxMTA4NjAy",
          "commit": {
            "abbreviatedOid": "0bd9bb8"
          },
          "author": "martinduke",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2021-07-07T14:50:51Z",
          "updatedAt": "2021-07-07T14:50:51Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAzNjc3Njc0",
          "commit": {
            "abbreviatedOid": "0bd9bb8"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-12T02:52:11Z",
          "updatedAt": "2021-07-12T02:52:11Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "```suggestion\r\nthat applications will want to differentiate between specific DATAGRAM frames\r\n```",
              "createdAt": "2021-07-12T02:52:11Z",
              "updatedAt": "2021-07-12T02:52:11Z"
            }
          ]
        }
      ]
    },
    {
      "number": 21,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg3NDY0ODc0",
      "title": "Update references to RFCs",
      "url": "https://github.com/quicwg/datagram/pull/21",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-07-12T02:57:03Z",
      "updatedAt": "2021-07-12T02:57:42Z",
      "baseRepository": "quicwg/datagram",
      "baseRefName": "main",
      "baseRefOid": "a74ac46449ab0226067e19c6bb7b8de9d9ba2d6b",
      "headRepository": "quicwg/datagram",
      "headRefName": "tfpauly-patch-1",
      "headRefOid": "f99689c2e414ab76a0fa5b351ae3b288ddeea9ea",
      "closedAt": "2021-07-12T02:57:42Z",
      "mergedAt": "2021-07-12T02:57:42Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "74d5f8d6ca78ab6981be06cb0313a37e1ab34e0e"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 22,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg3NDY2OTk5",
      "title": "Add a reference for sending probe packets",
      "url": "https://github.com/quicwg/datagram/pull/22",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "Closes #8",
      "createdAt": "2021-07-12T03:03:11Z",
      "updatedAt": "2021-07-12T19:42:03Z",
      "baseRepository": "quicwg/datagram",
      "baseRefName": "main",
      "baseRefOid": "74d5f8d6ca78ab6981be06cb0313a37e1ab34e0e",
      "headRepository": "quicwg/datagram",
      "headRefName": "tfpauly-patch-1",
      "headRefOid": "0e78f6ff35b4fc101ac726992cfc1fafb0243d5a",
      "closedAt": "2021-07-12T17:59:28Z",
      "mergedAt": "2021-07-12T17:59:28Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "0a57c01097a29f5f88d2f3743f33b3a15d4b329c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA0MTM0ODAy",
          "commit": {
            "abbreviatedOid": "42a1f35"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "This text is fine with me. I am wondering if we should say something additional, like that packets with datagram frames shouldn't be treated special, with respect to loss recovery. ",
          "createdAt": "2021-07-12T13:49:33Z",
          "updatedAt": "2021-07-12T13:49:33Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA0MzM4Nzk3",
          "commit": {
            "abbreviatedOid": "42a1f35"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "This text sounds good, though I'd love a little bit more text mentioning the benefit of this probe",
          "createdAt": "2021-07-12T16:55:01Z",
          "updatedAt": "2021-07-12T16:55:01Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA0MzQwMDYz",
          "commit": {
            "abbreviatedOid": "42a1f35"
          },
          "author": "ekinnear",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-12T16:56:19Z",
          "updatedAt": "2021-07-12T16:56:19Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA0MzkyMTgx",
          "commit": {
            "abbreviatedOid": "42a1f35"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-12T17:55:29Z",
          "updatedAt": "2021-07-12T17:55:30Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nAs with any ack-eliciting frame, when a sender suspects that a packet containing\r\nonly DATAGRAM frames has been lost, it MAY send probe packets to elicit a faster\r\nacknowledgement as described in Section 6.2.4 of {{!RFC9002}}.\r\n\r\n```",
              "createdAt": "2021-07-12T17:55:29Z",
              "updatedAt": "2021-07-12T17:55:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA0MzkyNTE5",
          "commit": {
            "abbreviatedOid": "42a1f35"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-12T17:55:55Z",
          "updatedAt": "2021-07-12T17:55:55Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Adding this change to make it clear that datagrams aren't special",
              "createdAt": "2021-07-12T17:55:55Z",
              "updatedAt": "2021-07-12T17:55:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA0NDc3NzI0",
          "commit": {
            "abbreviatedOid": "0e78f6f"
          },
          "author": "ianswett",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-12T19:42:03Z",
          "updatedAt": "2021-07-12T19:42:03Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "6.2.4 says you MUST send a probe packet, so it sounds like you're describing a slight departure from RFC9002?  I have no objection to that, but this text doesn't read that way to me.\r\n\r\nPossibly I'm misunderstanding what you're trying to say here?  Are you specifically trying to address the case where there are DATAGRAM frames in flight, but no data to send immediately?",
              "createdAt": "2021-07-12T19:42:03Z",
              "updatedAt": "2021-07-12T19:42:04Z"
            }
          ]
        }
      ]
    },
    {
      "number": 23,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg3NDY5ODM2",
      "title": "Transport acks != application processing",
      "url": "https://github.com/quicwg/datagram/pull/23",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "Closes #15",
      "createdAt": "2021-07-12T03:09:21Z",
      "updatedAt": "2021-07-12T17:53:48Z",
      "baseRepository": "quicwg/datagram",
      "baseRefName": "main",
      "baseRefOid": "74d5f8d6ca78ab6981be06cb0313a37e1ab34e0e",
      "headRepository": "quicwg/datagram",
      "headRefName": "tfpauly-patch-2",
      "headRefOid": "df50e1a6b0bfcc52353e8e029723138f50f95f01",
      "closedAt": "2021-07-12T17:53:47Z",
      "mergedAt": "2021-07-12T17:53:47Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "edae8d36c7acfd42127aaa47077e76973b10a015"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA0MTM3MTA1",
          "commit": {
            "abbreviatedOid": "4a1ec7f"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Text is good, but I am still a bit sad that we don't have some way to leverage the QUIC ACKs in a general sense (not implementation specific).",
          "createdAt": "2021-07-12T13:51:32Z",
          "updatedAt": "2021-07-12T13:51:32Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA0MTQ1NDky",
          "commit": {
            "abbreviatedOid": "4a1ec7f"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-12T13:58:29Z",
          "updatedAt": "2021-07-12T13:58:29Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "which application? The sender, receiver, or both?",
              "createdAt": "2021-07-12T13:58:29Z",
              "updatedAt": "2021-07-12T13:58:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA0MTQ5MDU2",
          "commit": {
            "abbreviatedOid": "4a1ec7f"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-12T14:01:22Z",
          "updatedAt": "2021-07-12T14:01:22Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I appreciate this text was already like this before the PR. However, IMO it wouldn't hurt to be specific here, the following sentences are. \r\n\r\nThis isn't a blocking issue, so go ahead and merge if you disagree.",
              "createdAt": "2021-07-12T14:01:22Z",
              "updatedAt": "2021-07-12T14:01:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA0MzQxNDQx",
          "commit": {
            "abbreviatedOid": "4a1ec7f"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-12T16:57:48Z",
          "updatedAt": "2021-07-12T16:58:38Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I agree with Lucas, how about:\r\n```suggestion\r\nimplementation MAY notify the sender application that the datagram was successfully\r\n```\r\nsame for line 251 above.",
              "createdAt": "2021-07-12T16:57:49Z",
              "updatedAt": "2021-07-12T16:58:38Z"
            }
          ]
        }
      ]
    },
    {
      "number": 25,
      "id": "MDExOlB1bGxSZXF1ZXN0NjkyMjA0MTg1",
      "title": "Probes are sent",
      "url": "https://github.com/quicwg/datagram/pull/25",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "RFC 9002 [doesn't\r\nequivocate](https://quicwg.org/base-drafts/rfc9002.html#name-sending-probe-packets)\r\nregarding whether probes are sent:\r\n\r\n> When a PTO timer expires, a sender MUST send at least one\r\nack-eliciting packet in the packet number space as a probe.\r\n\r\nThis text uses \"MAY\", which strongly suggests that probes are\r\ndiscretionary.\r\n\r\nThat's not true.",
      "createdAt": "2021-07-19T01:59:49Z",
      "updatedAt": "2021-07-19T20:22:13Z",
      "baseRepository": "quicwg/datagram",
      "baseRefName": "main",
      "baseRefOid": "0a57c01097a29f5f88d2f3743f33b3a15d4b329c",
      "headRepository": "martinthomson/datagram",
      "headRefName": "probes-are-sent",
      "headRefOid": "8eca105b9f6dc9c967d3df41ee48e20f392454b6",
      "closedAt": "2021-07-19T20:22:13Z",
      "mergedAt": "2021-07-19T20:22:13Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "87527787ac39acb44b27dcb6a381c21bca1cd994"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA5OTM4NzEz",
          "commit": {
            "abbreviatedOid": "8eca105"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-19T20:13:55Z",
          "updatedAt": "2021-07-19T20:13:55Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA5OTQ1MDk4",
          "commit": {
            "abbreviatedOid": "8eca105"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-19T20:22:08Z",
          "updatedAt": "2021-07-19T20:22:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 27,
      "id": "MDExOlB1bGxSZXF1ZXN0NjkyMjA2ODkz",
      "title": "Cannot rely on transport ACK",
      "url": "https://github.com/quicwg/datagram/pull/27",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The use of \"SHOULD NOT\" implies that a) this is discretionary, and b)\r\nthat applications might be able to rely on it in some cases.\r\n\r\nI don't believe that either is true unless the protocol were specified\r\nentirely differently.  (And that alternative specification wouldn't be\r\npractical anyway.)",
      "createdAt": "2021-07-19T02:05:20Z",
      "updatedAt": "2021-07-19T20:22:51Z",
      "baseRepository": "quicwg/datagram",
      "baseRefName": "main",
      "baseRefOid": "0a57c01097a29f5f88d2f3743f33b3a15d4b329c",
      "headRepository": "martinthomson/datagram",
      "headRefName": "just-cannot",
      "headRefOid": "6cc681a368687e82d2c286862b0ad9fbfcc35d76",
      "closedAt": "2021-07-19T20:22:51Z",
      "mergedAt": "2021-07-19T20:22:51Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "3323ff31ef00e0b61e8ee60734f67c7c5154cc66"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA5OTM5MTc0",
          "commit": {
            "abbreviatedOid": "6cc681a"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-19T20:14:32Z",
          "updatedAt": "2021-07-19T20:14:32Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA5OTQ1NjIw",
          "commit": {
            "abbreviatedOid": "6cc681a"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-19T20:22:46Z",
          "updatedAt": "2021-07-19T20:22:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 28,
      "id": "MDExOlB1bGxSZXF1ZXN0NjkyMjA5NTIx",
      "title": "Tweak motivation",
      "url": "https://github.com/quicwg/datagram/pull/28",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Drop the text on acknowledgments.\r\n\r\nCloses #26.\r\nCloses #24.\r\n\r\nThen modify the congestion control thing to make the benefit clearer.  A\r\nunified congestion controller can be more efficient.",
      "createdAt": "2021-07-19T02:11:11Z",
      "updatedAt": "2021-07-19T20:23:30Z",
      "baseRepository": "quicwg/datagram",
      "baseRefName": "main",
      "baseRefOid": "0a57c01097a29f5f88d2f3743f33b3a15d4b329c",
      "headRepository": "martinthomson/datagram",
      "headRefName": "acks-not-a-motivation",
      "headRefOid": "20a607ce6145032adaa99f2d1c79cc3da2194dfd",
      "closedAt": "2021-07-19T20:23:29Z",
      "mergedAt": "2021-07-19T20:23:29Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "1f5362f605ac973b65406bbf289a121cca14f392"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA5OTI1NjM1",
          "commit": {
            "abbreviatedOid": "20a607c"
          },
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-19T19:57:39Z",
          "updatedAt": "2021-07-19T19:57:39Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA5OTQ2MDk3",
          "commit": {
            "abbreviatedOid": "20a607c"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-19T20:23:22Z",
          "updatedAt": "2021-07-19T20:23:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 30,
      "id": "MDExOlB1bGxSZXF1ZXN0NjkyMjE4NjAz",
      "title": "0-RTT needs a profile",
      "url": "https://github.com/quicwg/datagram/pull/30",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Closes #29.",
      "createdAt": "2021-07-19T02:33:35Z",
      "updatedAt": "2021-07-19T20:28:46Z",
      "baseRepository": "quicwg/datagram",
      "baseRefName": "main",
      "baseRefOid": "0a57c01097a29f5f88d2f3743f33b3a15d4b329c",
      "headRepository": "martinthomson/datagram",
      "headRefName": "cite-9001",
      "headRefOid": "bb1fc2988b51c767710f497dc6d71fe92bf52edd",
      "closedAt": "2021-07-19T20:28:46Z",
      "mergedAt": "2021-07-19T20:28:45Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "e090b597a3d2d27401505b892938d03040bdf116"
      },
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "I put this in Security Considerations, but I can see that [Section 5](https://www.ietf.org/archive/id/draft-ietf-quic-datagram-03.html#name-behavior-and-usage) is another good choice (perhaps a better one).",
          "createdAt": "2021-07-19T02:37:07Z",
          "updatedAt": "2021-07-19T02:37:07Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree this could also be its own subsection of section 5, but given that this really is just reiterating an existing requirement, it's also OK where it is.",
          "createdAt": "2021-07-19T20:28:42Z",
          "updatedAt": "2021-07-19T20:28:42Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA5OTQwOTA2",
          "commit": {
            "abbreviatedOid": "bb1fc29"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-19T20:16:44Z",
          "updatedAt": "2021-07-19T20:16:44Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA5OTQ5ODI4",
          "commit": {
            "abbreviatedOid": "bb1fc29"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-19T20:28:02Z",
          "updatedAt": "2021-07-19T20:28:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 31,
      "id": "MDExOlB1bGxSZXF1ZXN0NjkyMjE5MDI3",
      "title": "Two items, and no comma",
      "url": "https://github.com/quicwg/datagram/pull/31",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-07-19T02:35:13Z",
      "updatedAt": "2021-07-19T20:24:07Z",
      "baseRepository": "quicwg/datagram",
      "baseRefName": "main",
      "baseRefOid": "0a57c01097a29f5f88d2f3743f33b3a15d4b329c",
      "headRepository": "martinthomson/datagram",
      "headRefName": "and-mtu",
      "headRefOid": "3bb5597e40585509374bd8ec0ed19fe616f4e5ac",
      "closedAt": "2021-07-19T20:24:06Z",
      "mergedAt": "2021-07-19T20:24:06Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "c1157b4d5638657803f40f4b5f13213bdeb8bae0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA5OTQwMDEx",
          "commit": {
            "abbreviatedOid": "3bb5597"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-19T20:15:39Z",
          "updatedAt": "2021-07-19T20:15:39Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA5OTQ2NTk4",
          "commit": {
            "abbreviatedOid": "3bb5597"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-19T20:24:01Z",
          "updatedAt": "2021-07-19T20:24:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 34,
      "id": "MDExOlB1bGxSZXF1ZXN0NjkzNTk1OTA4",
      "title": "Editorial changes to the introduction",
      "url": "https://github.com/quicwg/datagram/pull/34",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2021-07-20T15:57:57Z",
      "updatedAt": "2021-07-20T21:11:27Z",
      "baseRepository": "quicwg/datagram",
      "baseRefName": "main",
      "baseRefOid": "e090b597a3d2d27401505b892938d03040bdf116",
      "headRepository": "quicwg/datagram",
      "headRefName": "tfpauly-patch-1",
      "headRefOid": "7df4cf7787fee1dc4f11b01a25ba9fc2e1699897",
      "closedAt": "2021-07-20T21:11:26Z",
      "mergedAt": "2021-07-20T21:11:26Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "61ac20d5a2b6d312941c828810b1c11b31afaff9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzEwNzcxMzA2",
          "commit": {
            "abbreviatedOid": "5a95520"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Approved pending one nit",
          "createdAt": "2021-07-20T16:10:37Z",
          "updatedAt": "2021-07-20T16:11:10Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "nit: pick past or present (\"have built\" vs \"add\")\r\n```suggestion\r\ndirectly upon UDP {{?RFC0768}} as a transport, and have often added security with\r\n```",
              "createdAt": "2021-07-20T16:10:37Z",
              "updatedAt": "2021-07-20T16:11:10Z"
            }
          ]
        }
      ]
    },
    {
      "number": 36,
      "id": "MDExOlB1bGxSZXF1ZXN0NjkzODU5MzE2",
      "title": "Rework pacing phrasing",
      "url": "https://github.com/quicwg/datagram/pull/36",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "Closes #32",
      "createdAt": "2021-07-20T21:21:12Z",
      "updatedAt": "2021-08-07T01:47:20Z",
      "baseRepository": "quicwg/datagram",
      "baseRefName": "main",
      "baseRefOid": "61ac20d5a2b6d312941c828810b1c11b31afaff9",
      "headRepository": "quicwg/datagram",
      "headRefName": "tfpauly-patch-1",
      "headRefOid": "26c75bddd8b30496756815e93ad814cecc195092",
      "closedAt": "2021-08-07T01:47:19Z",
      "mergedAt": "2021-08-07T01:47:19Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "66f06a613154398ffc93f264d078a8b0bbed588b"
      },
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've dramatically simplified what we say for pacing now, to just call it out and the fact that it can add slight delays. @DavidSchinazi  @martinthomson  thoughts?",
          "createdAt": "2021-08-06T20:09:11Z",
          "updatedAt": "2021-08-06T20:09:11Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like the latest text, it's clear about things that are required, but it doesn't provide advice that we haven't tested. LGTM.",
          "createdAt": "2021-08-06T21:41:04Z",
          "updatedAt": "2021-08-06T21:41:04Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzExMDgxNTAz",
          "commit": {
            "abbreviatedOid": "a586173"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-20T21:27:39Z",
          "updatedAt": "2021-07-20T21:27:39Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Incorrect pacing would cause datagram frame loss, not packet loss. Here's a slightly tweaked phrasing:\r\n\r\n```suggestion\r\napplication). Implementations that use packet pacing ({{Section 7.7 of RFC9002}})\r\nSHOULD take care to avoid excessively dropping DATAGRAM frames due to the\r\ntransmission delays used for pacing.\r\n```\r\n\r\nThat said, as an implementer I'm not sure what this sentence tells me: \"take care\" is very vague. What's a concrete solution? Keeping pacing credits available in case datagrams come in?",
              "createdAt": "2021-07-20T21:27:39Z",
              "updatedAt": "2021-07-20T21:27:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzExMTIzMzkw",
          "commit": {
            "abbreviatedOid": "a586173"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-20T22:44:19Z",
          "updatedAt": "2021-07-20T22:44:20Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Realistically, it's \"don't drop a frame just because you're pacing\". This came from https://github.com/quicwg/datagram/issues/16 originally.\r\n\r\n@DavidSchinazi happy to take any suggested text here.",
              "createdAt": "2021-07-20T22:44:19Z",
              "updatedAt": "2021-07-20T22:44:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzExMTUyMDY5",
          "commit": {
            "abbreviatedOid": "a586173"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-20T23:54:02Z",
          "updatedAt": "2021-07-20T23:54:02Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "If the application passes a datagram to the transport and the transport can't send it right away due to pacing, what's the transport supposed to do? If I shouldn't drop it what am I supposed to do instead?",
              "createdAt": "2021-07-20T23:54:02Z",
              "updatedAt": "2021-07-20T23:54:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzExMjQ4NzU1",
          "commit": {
            "abbreviatedOid": "a586173"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-21T04:33:07Z",
          "updatedAt": "2021-07-21T05:22:55Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "I think that the phrasing you want is:\r\n> Implementations that use pacing (#REF) can delay the sending of DATAGRAM frames to maintain consistent packet pacing. DATAGRAM frames that are delayed too much might not meet delay constraints imposed by an application, in which case they can be dropped.\r\n\r\nNo normative language, nothing about trying to avoid excessive drops, delay comment applies to both sources of delay (CC and pacing).  You might then add an implementation note:\r\n\r\n> Implementations might need to balance the sending constraints imposed by congestion control and pacing against the delay constraints imposed by applications.\r\n\r\nI don't really think that's necessary though.",
              "createdAt": "2021-07-21T04:33:07Z",
              "updatedAt": "2021-07-21T05:22:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI0NzM1ODU0",
          "commit": {
            "abbreviatedOid": "26c75bd"
          },
          "author": "ekinnear",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "Small wording nits around \"allows it\" twice, but I don't have a radically better wording handy so looks good :) ",
          "createdAt": "2021-08-06T22:03:00Z",
          "updatedAt": "2021-08-06T22:03:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 37,
      "id": "MDExOlB1bGxSZXF1ZXN0NjkzODg1OTAz",
      "title": "Clarify scope to unreliable data only",
      "url": "https://github.com/quicwg/datagram/pull/37",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "Closes #12",
      "createdAt": "2021-07-20T21:55:22Z",
      "updatedAt": "2021-07-21T15:42:56Z",
      "baseRepository": "quicwg/datagram",
      "baseRefName": "main",
      "baseRefOid": "61ac20d5a2b6d312941c828810b1c11b31afaff9",
      "headRepository": "quicwg/datagram",
      "headRefName": "tfpauly-patch-2",
      "headRefOid": "5ff385951aa37c39e25eb52c50299a56e408c5dd",
      "closedAt": "2021-07-21T15:42:56Z",
      "mergedAt": "2021-07-21T15:42:55Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "bd2292fa743639e8790a5688b47e9dc67b533a20"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzExMTEyOTc4",
          "commit": {
            "abbreviatedOid": "ec86dba"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-20T22:22:28Z",
          "updatedAt": "2021-07-20T22:22:29Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nNote that DATAGRAM frames are only meant for unreliable transmissions. Reliable\r\ntransmission is already supported by QUIC via STREAM frames.\r\n```",
              "createdAt": "2021-07-20T22:22:29Z",
              "updatedAt": "2021-07-20T22:22:29Z"
            }
          ]
        }
      ]
    },
    {
      "number": 38,
      "id": "MDExOlB1bGxSZXF1ZXN0NjkzODkzMjAw",
      "title": "Note retransmission logic difference in security considerations",
      "url": "https://github.com/quicwg/datagram/pull/38",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "Closes #2",
      "createdAt": "2021-07-20T22:06:15Z",
      "updatedAt": "2021-07-21T15:44:19Z",
      "baseRepository": "quicwg/datagram",
      "baseRefName": "main",
      "baseRefOid": "61ac20d5a2b6d312941c828810b1c11b31afaff9",
      "headRepository": "quicwg/datagram",
      "headRefName": "tfpauly-patch-3",
      "headRefOid": "936d0e952393e2ed355100efc969b48edfc2fe80",
      "closedAt": "2021-07-21T15:44:19Z",
      "mergedAt": "2021-07-21T15:44:18Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "5adf366e4414318bfb2e45c806c06ac2b9e49b4f"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "Thank you!",
          "createdAt": "2021-07-20T22:52:23Z",
          "updatedAt": "2021-07-20T22:52:23Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzExMTE0NzI3",
          "commit": {
            "abbreviatedOid": "d021fc9"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-20T22:25:52Z",
          "updatedAt": "2021-07-20T22:25:52Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzExMTI2ODk1",
          "commit": {
            "abbreviatedOid": "d021fc9"
          },
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-20T22:52:15Z",
          "updatedAt": "2021-07-20T22:52:15Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzExMjQ2MzYx",
          "commit": {
            "abbreviatedOid": "d021fc9"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-21T04:26:07Z",
          "updatedAt": "2021-07-21T04:26:09Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nretransmission, connections that use DATAGRAM frames might be distinguished from\r\nother frames using the different response to loss.\r\n```",
              "createdAt": "2021-07-21T04:26:07Z",
              "updatedAt": "2021-07-21T04:26:10Z"
            }
          ]
        }
      ]
    },
    {
      "number": 39,
      "id": "MDExOlB1bGxSZXF1ZXN0NjkzODk4MjY2",
      "title": "Update acknowledgements",
      "url": "https://github.com/quicwg/datagram/pull/39",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "Closes #33\r\n\r\nLet me know if anyone else should be added!",
      "createdAt": "2021-07-20T22:13:05Z",
      "updatedAt": "2021-07-21T15:43:07Z",
      "baseRepository": "quicwg/datagram",
      "baseRefName": "main",
      "baseRefOid": "61ac20d5a2b6d312941c828810b1c11b31afaff9",
      "headRepository": "quicwg/datagram",
      "headRefName": "tfpauly-patch-4",
      "headRefOid": "83dbc4dbae8db3d3a7691120acb33eaac89a78db",
      "closedAt": "2021-07-21T15:43:06Z",
      "mergedAt": "2021-07-21T15:43:06Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "a1c47ed8185a3f08fbd28266a62fe74efb2600be"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzExMTE1MTc4",
          "commit": {
            "abbreviatedOid": "0428991"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-20T22:26:43Z",
          "updatedAt": "2021-07-20T22:26:48Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "nit: order names alphabetically by last name?",
              "createdAt": "2021-07-20T22:26:44Z",
              "updatedAt": "2021-07-20T22:26:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzExMTI0Mzk0",
          "commit": {
            "abbreviatedOid": "83dbc4d"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-20T22:46:28Z",
          "updatedAt": "2021-07-20T22:46:28Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Done!",
              "createdAt": "2021-07-20T22:46:28Z",
              "updatedAt": "2021-07-20T22:46:28Z"
            }
          ]
        }
      ]
    },
    {
      "number": 40,
      "id": "MDExOlB1bGxSZXF1ZXN0Njk1NTYzNjQ1",
      "title": "Acknowledge Victor",
      "url": "https://github.com/quicwg/datagram/pull/40",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-07-22T23:06:43Z",
      "updatedAt": "2021-07-27T19:02:11Z",
      "baseRepository": "quicwg/datagram",
      "baseRefName": "main",
      "baseRefOid": "5adf366e4414318bfb2e45c806c06ac2b9e49b4f",
      "headRepository": "quicwg/datagram",
      "headRefName": "vvv",
      "headRefOid": "e8728c40f035f75b764537dec096712783c6ba1d",
      "closedAt": "2021-07-27T19:02:10Z",
      "mergedAt": "2021-07-27T19:02:10Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "67b81e9dcf21fb83f66c750ff4b9c05729042f98"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE2Mjc3MTcx",
          "commit": {
            "abbreviatedOid": "e8728c4"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-27T19:02:05Z",
          "updatedAt": "2021-07-27T19:02:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 44,
      "id": "MDExOlB1bGxSZXF1ZXN0Njk5OTI5OTk4",
      "title": "Datagram No Ack TP Proposal",
      "url": "https://github.com/quicwg/datagram/pull/44",
      "state": "CLOSED",
      "author": "nibanks",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "One possible solution for #42. This could be pushed into a separate extension if preferred.",
      "createdAt": "2021-07-30T01:02:06Z",
      "updatedAt": "2021-09-16T20:07:31Z",
      "baseRepository": "quicwg/datagram",
      "baseRefName": "main",
      "baseRefOid": "67b81e9dcf21fb83f66c750ff4b9c05729042f98",
      "headRepository": "nibanks/datagram",
      "headRefName": "patch-1",
      "headRefOid": "847bb65881d9a7c3f0f6be5dc061e3bd543bf93b",
      "closedAt": "2021-09-16T20:07:31Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 45,
      "id": "MDExOlB1bGxSZXF1ZXN0NzAwNDk2NjYw",
      "title": "Datagram No Ack Frame Proposal",
      "url": "https://github.com/quicwg/datagram/pull/45",
      "state": "CLOSED",
      "author": "nibanks",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Another possible solution for #42.",
      "createdAt": "2021-07-30T18:44:33Z",
      "updatedAt": "2021-09-16T20:07:24Z",
      "baseRepository": "quicwg/datagram",
      "baseRefName": "main",
      "baseRefOid": "67b81e9dcf21fb83f66c750ff4b9c05729042f98",
      "headRepository": "nibanks/datagram",
      "headRefName": "patch-2",
      "headRefOid": "9f23a38a25f887dd3026fd1e294aaf275b2196b4",
      "closedAt": "2021-09-16T20:07:24Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "This proposal makes the frame mandatory to implement, which means we'd be creating work for dependent documents such as the HTTP/3 datagram draft and WebTransport HTTP/3 mapping, which is owned are owned by MASQUE and WebTransport. Although the authors of the documents are active in the various WG, the wider group would probably need some awareness of such a change.\r\n\r\nAn easy way to avoid that is to require a separate Transport Parameter for using these frame types i.e. `max_datagram_no_ack_frame_size` . That way, implementations and deployments can decide whether they want to support it, and they can clearly communicate that to peers. The natural consequence is that the design becomes a separable extension that builds on top of DATAGRAM, and so it could be pitched to the QUIC WG independent of this draft.",
          "createdAt": "2021-08-03T14:51:05Z",
          "updatedAt": "2021-08-03T14:51:05Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed with Lucas. A transport parameter would be preferable here, and I do see it as more of an extension to the extension, rather than a fundamental part of DATAGRAM.",
          "createdAt": "2021-08-06T16:52:45Z",
          "updatedAt": "2021-08-06T16:52:45Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 46,
      "id": "MDExOlB1bGxSZXF1ZXN0NzAxNDIwOTEw",
      "title": "update frame definition format",
      "url": "https://github.com/quicwg/datagram/pull/46",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "and a bit of editorializing of thee text to match RFC 9000.\r\n\r\nFixes #43",
      "createdAt": "2021-08-02T12:25:58Z",
      "updatedAt": "2021-08-06T16:50:24Z",
      "baseRepository": "quicwg/datagram",
      "baseRefName": "main",
      "baseRefOid": "67b81e9dcf21fb83f66c750ff4b9c05729042f98",
      "headRepository": "quicwg/datagram",
      "headRefName": "lucas/editorialize-frame-def",
      "headRefOid": "8d85d42748f9611d55f318153aa0d4e8b6354a91",
      "closedAt": "2021-08-06T16:50:24Z",
      "mergedAt": "2021-08-06T16:50:23Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "cf91259599049db38701447107ba331d8c6d2279"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIwMzkxMDYy",
          "commit": {
            "abbreviatedOid": "8d85d42"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-02T16:30:32Z",
          "updatedAt": "2021-08-02T16:30:32Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI0NTQyMTEw",
          "commit": {
            "abbreviatedOid": "8d85d42"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-06T16:50:10Z",
          "updatedAt": "2021-08-06T16:50:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 48,
      "id": "MDExOlB1bGxSZXF1ZXN0NzIzNzQzMDQy",
      "title": "Clarify recommendation on datagram acknowledgements",
      "url": "https://github.com/quicwg/datagram/pull/48",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This was a suggestion from @MikeBishop.\r\n\r\nFixes #47",
      "createdAt": "2021-08-31T20:31:31Z",
      "updatedAt": "2021-08-31T22:02:19Z",
      "baseRepository": "quicwg/datagram",
      "baseRefName": "main",
      "baseRefOid": "66f06a613154398ffc93f264d078a8b0bbed588b",
      "headRepository": "quicwg/datagram",
      "headRefName": "not_used_recovery",
      "headRefOid": "b26e656e060715adbfff5cfe3e7bee83b83e8b03",
      "closedAt": "2021-08-31T22:02:18Z",
      "mergedAt": "2021-08-31T22:02:18Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "58113339500f27f0e3968c5e69da331a157c7f56"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQzMTcwMTI2",
          "commit": {
            "abbreviatedOid": "9540fe2"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "This is an editorial change that clarifies the intent of the text.",
          "createdAt": "2021-08-31T20:35:04Z",
          "updatedAt": "2021-08-31T20:35:04Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQzMTcxMTEz",
          "commit": {
            "abbreviatedOid": "9540fe2"
          },
          "author": "ekinnear",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "Seems strictly more clear, nice!",
          "createdAt": "2021-08-31T20:36:14Z",
          "updatedAt": "2021-08-31T20:36:14Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQzMTkzMTYx",
          "commit": {
            "abbreviatedOid": "9540fe2"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "A few nits. I'm also wondering if we should just leave the old sentence ending with \"is not used for loss recovery\", and then explain it.",
          "createdAt": "2021-08-31T21:04:03Z",
          "updatedAt": "2021-08-31T21:05:39Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "We're not adding new normative behavior for acknowledgements, so I think we should just state the fact of how QUIC will behave here.\r\n\r\n```suggestion\r\naction if these packets are temporarily unacknowledged. Receivers will\r\n```",
              "createdAt": "2021-08-31T21:04:03Z",
              "updatedAt": "2021-08-31T21:05:39Z"
            },
            {
              "originalPosition": 11,
              "body": "What does the \"payload is unknown\" mean?",
              "createdAt": "2021-08-31T21:04:26Z",
              "updatedAt": "2021-08-31T21:05:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQzMjIzNDcw",
          "commit": {
            "abbreviatedOid": "b26e656"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-31T21:47:02Z",
          "updatedAt": "2021-08-31T21:47:02Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Unknown as in \"you do not know the contents of a packet that you never received\", so if you see packet numbers 1,2,3,5,6,7,8 you don't know if packet 4 was datagram-only or not, so you shouldn't treat 4 as datagram-only",
              "createdAt": "2021-08-31T21:47:02Z",
              "updatedAt": "2021-08-31T21:47:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQzMjMyMTQx",
          "commit": {
            "abbreviatedOid": "b26e656"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-31T22:01:16Z",
          "updatedAt": "2021-08-31T22:01:17Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Ah, got it.",
              "createdAt": "2021-08-31T22:01:17Z",
              "updatedAt": "2021-08-31T22:01:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQzMjMyMjE3",
          "commit": {
            "abbreviatedOid": "b26e656"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-31T22:01:25Z",
          "updatedAt": "2021-08-31T22:01:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 53,
      "id": "PR_kwDODoD7Ms4r3Yxd",
      "title": "Not \"strongly\" associated",
      "url": "https://github.com/quicwg/datagram/pull/53",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "Closes #52",
      "createdAt": "2021-09-17T00:06:00Z",
      "updatedAt": "2021-09-17T01:59:40Z",
      "baseRepository": "quicwg/datagram",
      "baseRefName": "main",
      "baseRefOid": "58113339500f27f0e3968c5e69da331a157c7f56",
      "headRepository": "quicwg/datagram",
      "headRefName": "tfpauly-patch-1",
      "headRefOid": "ced65b0ddfbe041a4d07953c842ddcc982d37952",
      "closedAt": "2021-09-17T01:59:39Z",
      "mergedAt": "2021-09-17T01:59:39Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "5b9fa5dfa22662454df8baf5206d300773821f23"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD7Ms4tHhEi",
          "commit": {
            "abbreviatedOid": "ced65b0"
          },
          "author": "ekinnear",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "Thank you!",
          "createdAt": "2021-09-17T00:06:35Z",
          "updatedAt": "2021-09-17T00:06:35Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODoD7Ms4tHiGp",
          "commit": {
            "abbreviatedOid": "ced65b0"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-17T00:17:36Z",
          "updatedAt": "2021-09-17T00:17:36Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODoD7Ms4tHj2O",
          "commit": {
            "abbreviatedOid": "ced65b0"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-17T00:37:47Z",
          "updatedAt": "2021-09-17T00:37:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 55,
      "id": "PR_kwDODoD7Ms4sN4Ek",
      "title": "Minor last call comments",
      "url": "https://github.com/quicwg/datagram/pull/55",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Minor editorial changes from WGLC comments.",
      "createdAt": "2021-09-24T01:04:51Z",
      "updatedAt": "2021-09-28T02:35:03Z",
      "baseRepository": "quicwg/datagram",
      "baseRefName": "main",
      "baseRefOid": "5b9fa5dfa22662454df8baf5206d300773821f23",
      "headRepository": "SpencerDawkins/datagram",
      "headRefName": "sd-wglc-comments",
      "headRefOid": "a794d21fa7b692a18a1e2f94502828dc83a972be",
      "closedAt": "2021-09-28T02:35:03Z",
      "mergedAt": "2021-09-28T02:35:03Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "19976c8aaafc9a110b620bd1adc27ea77bd908bc"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD7Ms4tdRLn",
          "commit": {
            "abbreviatedOid": "32df646"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Works for me! Thanks @SpencerDawkins.",
          "createdAt": "2021-09-24T02:37:40Z",
          "updatedAt": "2021-09-24T02:37:40Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODoD7Ms4tfsom",
          "commit": {
            "abbreviatedOid": "32df646"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks for writing this Spencer, much appreciated!",
          "createdAt": "2021-09-24T16:45:16Z",
          "updatedAt": "2021-09-24T16:45:34Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "```suggestion\r\nWhen an application sends a datagram over a QUIC connection,\r\n```",
              "createdAt": "2021-09-24T16:45:17Z",
              "updatedAt": "2021-09-24T16:45:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7Ms4tl6Hs",
          "commit": {
            "abbreviatedOid": "a794d21"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-28T02:34:58Z",
          "updatedAt": "2021-09-28T02:34:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 57,
      "id": "PR_kwDODoD7Ms4sVNZY",
      "title": "grammar nit",
      "url": "https://github.com/quicwg/datagram/pull/57",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "could also do s/,/; but whatever.",
      "createdAt": "2021-09-27T19:24:37Z",
      "updatedAt": "2021-09-27T20:03:34Z",
      "baseRepository": "quicwg/datagram",
      "baseRefName": "main",
      "baseRefOid": "5b9fa5dfa22662454df8baf5206d300773821f23",
      "headRepository": "martinduke/datagram",
      "headRefName": "mduke-nit",
      "headRefOid": "ec814294a1c0f5a213e19d05a36f76386707d64d",
      "closedAt": "2021-09-27T20:03:34Z",
      "mergedAt": "2021-09-27T20:03:34Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "ccadacc3b5fa199e131621f84d4cdec7358b7985"
      },
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not qualified to handle this level of copy-editing, this sounds like something best suited for the RFC editor.",
          "createdAt": "2021-09-27T19:55:49Z",
          "updatedAt": "2021-09-27T19:55:49Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODoD7Ms4tlGBW",
          "commit": {
            "abbreviatedOid": "d277dc8"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-27T20:03:06Z",
          "updatedAt": "2021-09-27T20:03:07Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\n(MTU) of the path between endpoints. DATAGRAM frames cannot be fragmented;\r\ntherefore, application protocols need to handle cases where the maximum datagram\r\n```",
              "createdAt": "2021-09-27T20:03:07Z",
              "updatedAt": "2021-09-27T20:03:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7Ms4tlGFl",
          "commit": {
            "abbreviatedOid": "d277dc8"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-27T20:03:25Z",
          "updatedAt": "2021-09-27T20:03:25Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I prefer this approach",
              "createdAt": "2021-09-27T20:03:25Z",
              "updatedAt": "2021-09-27T20:03:25Z"
            }
          ]
        }
      ]
    },
    {
      "number": 58,
      "id": "PR_kwDODoD7Ms4sVwzq",
      "title": "Update intro about reliable/unreliable data",
      "url": "https://github.com/quicwg/datagram/pull/58",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "Closes #56",
      "createdAt": "2021-09-27T22:01:05Z",
      "updatedAt": "2021-09-28T02:40:07Z",
      "baseRepository": "quicwg/datagram",
      "baseRefName": "main",
      "baseRefOid": "ccadacc3b5fa199e131621f84d4cdec7358b7985",
      "headRepository": "quicwg/datagram",
      "headRefName": "tfpauly-patch-1",
      "headRefOid": "2d22df65a9792982f7d909ae6d74cd4c1898c5b2",
      "closedAt": "2021-09-28T02:40:06Z",
      "mergedAt": "2021-09-28T02:40:06Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "8e9992b383118c80b6e39b2df2deaff9514ef710"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD7Ms4tlfg9",
          "commit": {
            "abbreviatedOid": "e09483d"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2021-09-27T22:21:51Z",
          "updatedAt": "2021-09-27T22:21:51Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODoD7Ms4tlfvX",
          "commit": {
            "abbreviatedOid": "e09483d"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-27T22:23:38Z",
          "updatedAt": "2021-09-27T22:23:38Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "change look fine but is pretty duplicative of L74-75. Maybe remove that text?",
              "createdAt": "2021-09-27T22:23:38Z",
              "updatedAt": "2021-09-27T22:23:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7Ms4tljLg",
          "commit": {
            "abbreviatedOid": "e09483d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM modulo one comment",
          "createdAt": "2021-09-27T22:50:42Z",
          "updatedAt": "2021-09-27T22:50:50Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I agree with Lucas, the new text makes L74-75 redundant so I'd remove L74-75",
              "createdAt": "2021-09-27T22:50:42Z",
              "updatedAt": "2021-09-27T22:50:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7Ms4tl6kQ",
          "commit": {
            "abbreviatedOid": "2d22df6"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-28T02:39:55Z",
          "updatedAt": "2021-09-28T02:39:55Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Sounds good, removed those redundant lines.",
              "createdAt": "2021-09-28T02:39:55Z",
              "updatedAt": "2021-09-28T02:39:55Z"
            }
          ]
        }
      ]
    },
    {
      "number": 60,
      "id": "PR_kwDODoD7Ms4sqZit",
      "title": "Make IANA registrations permanent",
      "url": "https://github.com/quicwg/datagram/pull/60",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The IANA section was added before the QUIC registries had a notion of permanent vs provisional, and we then forgot to update it. This PR fixes that oversight.\r\n\r\nFixes #59.\r\nFixes #61.",
      "createdAt": "2021-10-04T21:12:06Z",
      "updatedAt": "2021-10-05T13:47:36Z",
      "baseRepository": "quicwg/datagram",
      "baseRefName": "main",
      "baseRefOid": "8e9992b383118c80b6e39b2df2deaff9514ef710",
      "headRepository": "quicwg/datagram",
      "headRefName": "permanent",
      "headRefOid": "43579bc94fd09309a2293d47e6dda31426c94494",
      "closedAt": "2021-10-05T13:47:35Z",
      "mergedAt": "2021-10-05T13:47:35Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "86d868050097a87c3a6ea217fa1fe51438b3c946"
      },
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Latest change looks good to me",
          "createdAt": "2021-10-04T22:52:58Z",
          "updatedAt": "2021-10-04T22:52:58Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODoD7Ms4t8Tni",
          "commit": {
            "abbreviatedOid": "8496179"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM, thanks!",
          "createdAt": "2021-10-04T21:20:47Z",
          "updatedAt": "2021-10-04T21:20:47Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODoD7Ms4t8geD",
          "commit": {
            "abbreviatedOid": "8496179"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-04T22:47:42Z",
          "updatedAt": "2021-10-04T22:47:42Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODoD7Ms4t8qR4",
          "commit": {
            "abbreviatedOid": "43579bc"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-05T00:23:46Z",
          "updatedAt": "2021-10-05T00:23:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 62,
      "id": "PR_kwDODoD7Ms4sqdwr",
      "title": "rough in shepherd writeup",
      "url": "https://github.com/quicwg/datagram/pull/62",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-10-04T21:39:43Z",
      "updatedAt": "2021-10-11T21:53:20Z",
      "baseRepository": "quicwg/datagram",
      "baseRefName": "main",
      "baseRefOid": "8e9992b383118c80b6e39b2df2deaff9514ef710",
      "headRepository": "quicwg/datagram",
      "headRefName": "shepherd-writeup",
      "headRefOid": "c8d242e81d5c8b83b0d63abf31f266c1e1141930",
      "closedAt": "2021-10-11T21:53:19Z",
      "mergedAt": "2021-10-11T21:53:19Z",
      "mergedBy": "mjoras",
      "mergeCommit": {
        "oid": "cde5858964fc410d32dd2db33d815eb1c8ed4f77"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD7Ms4uSvby",
          "commit": {
            "abbreviatedOid": "5c8e413"
          },
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-11T21:10:02Z",
          "updatedAt": "2021-10-11T21:11:16Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Might want to be slightly careful here. I don't think technically speaking ack-frequency resolves the issue entirely, but does provide a related mechanism.",
              "createdAt": "2021-10-11T21:10:02Z",
              "updatedAt": "2021-10-11T21:11:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7Ms4uSv1b",
          "commit": {
            "abbreviatedOid": "5c8e413"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-11T21:12:55Z",
          "updatedAt": "2021-10-11T21:12:56Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "good point!",
              "createdAt": "2021-10-11T21:12:55Z",
              "updatedAt": "2021-10-11T21:12:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7Ms4uSxhy",
          "commit": {
            "abbreviatedOid": "c8d242e"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-11T21:24:54Z",
          "updatedAt": "2021-10-11T21:24:54Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Since there is not a concrete proposal in ack-frequency its a distraction to mention it. I reworded things to take the focus onto general extensibility.",
              "createdAt": "2021-10-11T21:24:54Z",
              "updatedAt": "2021-10-11T21:24:54Z"
            }
          ]
        }
      ]
    },
    {
      "number": 69,
      "id": "PR_kwDODoD7Ms4vc-0v",
      "title": "Explain 0-RTT/1-RTT requirement",
      "url": "https://github.com/quicwg/datagram/pull/69",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "Closes #65",
      "createdAt": "2021-12-06T17:51:56Z",
      "updatedAt": "2021-12-07T16:00:22Z",
      "baseRepository": "quicwg/datagram",
      "baseRefName": "main",
      "baseRefOid": "cde5858964fc410d32dd2db33d815eb1c8ed4f77",
      "headRepository": "quicwg/datagram",
      "headRefName": "tfpauly-patch-1",
      "headRefOid": "3126d5567daeca2b43631d2967c43cd106717215",
      "closedAt": "2021-12-07T16:00:21Z",
      "mergedAt": "2021-12-07T16:00:20Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "99d93aee840d6baeff2a7f7c694579c95fdbf2c5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD7Ms4xIo20",
          "commit": {
            "abbreviatedOid": "57bbb60"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-12-06T18:58:58Z",
          "updatedAt": "2021-12-06T18:58:58Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODoD7Ms4xJLwf",
          "commit": {
            "abbreviatedOid": "57bbb60"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-06T21:18:03Z",
          "updatedAt": "2021-12-06T21:18:06Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nLike STREAM frames, DATAGRAM frames contain application data and MUST be protected with either 0-RTT or\r\n```",
              "createdAt": "2021-12-06T21:18:04Z",
              "updatedAt": "2021-12-06T21:18:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7Ms4xJg5R",
          "commit": {
            "abbreviatedOid": "57bbb60"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-06T22:53:51Z",
          "updatedAt": "2021-12-06T22:53:53Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nLike STREAM frames, DATAGRAM frames contain application data and MUST be protected\r\nwith either 0-RTT or 1-RTT keys.\r\n```",
              "createdAt": "2021-12-06T22:53:51Z",
              "updatedAt": "2021-12-06T22:53:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7Ms4xJs19",
          "commit": {
            "abbreviatedOid": "3126d55"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-12-07T00:01:27Z",
          "updatedAt": "2021-12-07T00:01:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 70,
      "id": "PR_kwDODoD7Ms4vc_ol",
      "title": "Explain VLI demux rationale",
      "url": "https://github.com/quicwg/datagram/pull/70",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "Closes #66",
      "createdAt": "2021-12-06T17:56:52Z",
      "updatedAt": "2021-12-07T23:03:08Z",
      "baseRepository": "quicwg/datagram",
      "baseRefName": "main",
      "baseRefOid": "cde5858964fc410d32dd2db33d815eb1c8ed4f77",
      "headRepository": "quicwg/datagram",
      "headRefName": "tfpauly-patch-2",
      "headRefOid": "f48302221b392b90525f58aae9ffbe83070f1caa",
      "closedAt": "2021-12-07T23:03:08Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Already merged",
          "createdAt": "2021-12-07T23:03:08Z",
          "updatedAt": "2021-12-07T23:03:08Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODoD7Ms4xJsqO",
          "commit": {
            "abbreviatedOid": "f483022"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-12-07T00:00:33Z",
          "updatedAt": "2021-12-07T00:00:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 71,
      "id": "PR_kwDODoD7Ms4vdSVi",
      "title": "Replace with Discussion Venue",
      "url": "https://github.com/quicwg/datagram/pull/71",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-12-06T19:27:15Z",
      "updatedAt": "2021-12-06T20:05:52Z",
      "baseRepository": "quicwg/datagram",
      "baseRefName": "main",
      "baseRefOid": "cde5858964fc410d32dd2db33d815eb1c8ed4f77",
      "headRepository": "quicwg/datagram",
      "headRefName": "tfpauly-patch-3",
      "headRefOid": "a5a2565b06cdbf10dd607acbd41007a031569e9b",
      "closedAt": "2021-12-06T20:05:51Z",
      "mergedAt": "2021-12-06T20:05:51Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "a5a2565b06cdbf10dd607acbd41007a031569e9b"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 72,
      "id": "PR_kwDODoD7Ms4vdZh3",
      "title": "Discussion venue",
      "url": "https://github.com/quicwg/datagram/pull/72",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This should get the discussion venue automatically populated, and is based on #71 ",
      "createdAt": "2021-12-06T20:04:42Z",
      "updatedAt": "2021-12-06T20:05:50Z",
      "baseRepository": "quicwg/datagram",
      "baseRefName": "main",
      "baseRefOid": "cde5858964fc410d32dd2db33d815eb1c8ed4f77",
      "headRepository": "quicwg/datagram",
      "headRefName": "discussion_venue",
      "headRefOid": "f20139ceea323288c50eaa7d3dabcc5fe51d1752",
      "closedAt": "2021-12-06T20:05:49Z",
      "mergedAt": "2021-12-06T20:05:49Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "bad57c6c723f9490d7e7c54ced5e2facd76e16fc"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 73,
      "id": "PR_kwDODoD7Ms4veGtd",
      "title": "Include \"About this draft\" information in the markdown",
      "url": "https://github.com/quicwg/datagram/pull/73",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This is a relatively new feature for the kramdown format and it's been tweaked to be nicer.",
      "createdAt": "2021-12-07T00:24:14Z",
      "updatedAt": "2021-12-07T01:06:20Z",
      "baseRepository": "quicwg/datagram",
      "baseRefName": "main",
      "baseRefOid": "bad57c6c723f9490d7e7c54ced5e2facd76e16fc",
      "headRepository": "martinthomson/datagram",
      "headRefName": "venue",
      "headRefOid": "f02eab2994ffb1c1ce72a310d792b7f90f945045",
      "closedAt": "2021-12-07T01:05:25Z",
      "mergedAt": "2021-12-07T01:05:25Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "0468282b577c0f4d876237dd7714fd1a9d7e1d87"
      },
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I found MT's [update instructions](https://github.com/martinthomson/i-d-template/blob/main/doc/SETUP.md#update) and after fighting with macOS permissions (we need better hobbies) I got this to work, and now it looks pretty. I'd say this is OK to merge if both @tfpauly and @erickinnear confirm that they have the updated tools",
          "createdAt": "2021-12-07T01:02:15Z",
          "updatedAt": "2021-12-07T01:02:15Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "Yeah, this constant churn in the tools is annoying.  I found that I have a nasty, long path on my install/upgrade due to ruby being bad at this.",
          "createdAt": "2021-12-07T01:05:48Z",
          "updatedAt": "2021-12-07T01:05:48Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODoD7Ms4xJzYv",
          "commit": {
            "abbreviatedOid": "f02eab2"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "This doesn't seem to work for me. I checked out [martinthomson:venue](https://github.com/martinthomson/datagram/tree/venue) and it removes the \"Discussion Venues\" section.\r\n\r\n```\r\n$ make\r\ngit clone -q --depth 10 -b main https://github.com/martinthomson/i-d-template.git lib\r\nlib/main.mk:21: Forcing rebuild of .targets.mk\r\ncat draft-ietf-quic-datagram.md  | kramdown-rfc2629 --v3 | lib/add-note.py | xml2rfc -q -s 'Setting consensus=\"true\" for IETF STD document' --rfc-base-url https://www.rfc-editor.org/rfc/ --id-base-url https://datatracker.ietf.org/doc/html/ --cache=/Users/dschinazi/.cache/xml2rfc --v2v3 /dev/stdin -o /dev/stdout >draft-ietf-quic-datagram.xml\r\n** Can't set up persistent HTTP -- cannot load such file -- net/http/persistent\r\n*** attributes left {\"venue\"=>{\"group\"=>\"QUIC\", \"type\"=>\"Working Group\", \"mail\"=>\"quic@ietf.org\", \"arch\"=>\"https://mailarchive.ietf.org/arch/browse/quic/\", \"github\"=>\"quicwg/datagram\", \"latest\"=>\"https://quicwg.github.io/datagram/draft-ietf-quic-datagram.html\"}}!\r\n/Users/dschinazi/.cache/xml2rfc/reference.RFC.9000.xml: renewing (stale by 7.0 days) from https://www.rfc-editor.org/refs/bibxml/reference.RFC.9000.xml\r\n/Users/dschinazi/.cache/xml2rfc/reference.RFC.2119.xml: renewing (stale by 7.0 days) from https://www.rfc-editor.org/refs/bibxml/reference.RFC.2119.xml\r\n/Users/dschinazi/.cache/xml2rfc/reference.RFC.8174.xml: renewing (stale by 7.0 days) from https://www.rfc-editor.org/refs/bibxml/reference.RFC.8174.xml\r\nxml2rfc -q -s 'Setting consensus=\"true\" for IETF STD document' --rfc-base-url https://www.rfc-editor.org/rfc/ --id-base-url https://datatracker.ietf.org/doc/html/ --cache=/Users/dschinazi/.cache/xml2rfc draft-ietf-quic-datagram.xml -o draft-ietf-quic-datagram.txt --text --no-pagination\r\nxml2rfc -q -s 'Setting consensus=\"true\" for IETF STD document' --rfc-base-url https://www.rfc-editor.org/rfc/ --id-base-url https://datatracker.ietf.org/doc/html/ --cache=/Users/dschinazi/.cache/xml2rfc --css=lib/v3.css --metadata-js-url=/dev/null draft-ietf-quic-datagram.xml -o draft-ietf-quic-datagram.html --html\r\nrm draft-ietf-quic-datagram.xml\r\n```",
          "createdAt": "2021-12-07T00:43:49Z",
          "updatedAt": "2021-12-07T00:43:49Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODoD7Ms4xJ2-W",
          "commit": {
            "abbreviatedOid": "f02eab2"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Seems fine to me!",
          "createdAt": "2021-12-07T01:05:20Z",
          "updatedAt": "2021-12-07T01:05:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 74,
      "id": "PR_kwDODoD7Ms4v2-Te",
      "title": "Clarify fingerprinting security consideration",
      "url": "https://github.com/quicwg/datagram/pull/74",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "Addresses Opsdir review comment",
      "createdAt": "2021-12-15T00:33:37Z",
      "updatedAt": "2021-12-15T05:54:04Z",
      "baseRepository": "quicwg/datagram",
      "baseRefName": "main",
      "baseRefOid": "61299cfa3cec9815109604e274ada270372b314f",
      "headRepository": "quicwg/datagram",
      "headRefName": "tfpauly-patch-1",
      "headRefOid": "cc9af8c986bab998b1e24024084aa7251233a995",
      "closedAt": "2021-12-15T05:54:04Z",
      "mergedAt": "2021-12-15T05:54:04Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "bf5ec7702d7489a8bec0f65d726d21e09b2a6a3d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD7Ms4xmjPh",
          "commit": {
            "abbreviatedOid": "cc9af8c"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks",
          "createdAt": "2021-12-15T00:43:07Z",
          "updatedAt": "2021-12-15T00:43:07Z",
          "comments": []
        }
      ]
    },
    {
      "number": 75,
      "id": "PR_kwDODoD7Ms4xDT2m",
      "title": "Clarify 0-RTT TP",
      "url": "https://github.com/quicwg/datagram/pull/75",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #63 ",
      "createdAt": "2022-01-14T17:42:26Z",
      "updatedAt": "2022-01-14T17:42:42Z",
      "baseRepository": "quicwg/datagram",
      "baseRefName": "main",
      "baseRefOid": "bf5ec7702d7489a8bec0f65d726d21e09b2a6a3d",
      "headRepository": "quicwg/datagram",
      "headRefName": "clarify_0rtt",
      "headRefOid": "f44720a432161452eff931320a949d879780b3a4",
      "closedAt": "2022-01-14T17:42:41Z",
      "mergedAt": "2022-01-14T17:42:41Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "829b19ab79803957bbf359231512b46e80be58cf"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 76,
      "id": "PR_kwDODoD7Ms4xwvrq",
      "title": "Editorial suggestions from Benjamin Kaduk's IESG Evaluation",
      "url": "https://github.com/quicwg/datagram/pull/76",
      "state": "MERGED",
      "author": "kaduk",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-01-28T22:21:43Z",
      "updatedAt": "2022-01-28T22:58:31Z",
      "baseRepository": "quicwg/datagram",
      "baseRefName": "main",
      "baseRefOid": "d5061e5747901316b5b9d680c987f8a6e0c88951",
      "headRepository": "kaduk/datagram",
      "headRefName": "nits",
      "headRefOid": "ef311c16fc4247b457d1812608961b593f3e0090",
      "closedAt": "2022-01-28T22:58:31Z",
      "mergedAt": "2022-01-28T22:58:31Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "aba65326e8821243c54ca8df42b5fedf264ea30f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD7Ms4zqcgG",
          "commit": {
            "abbreviatedOid": "94c25d8"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for this, in particular finding the outdated TP name! I like changes 2 and 3 out of 3 but would prefer to skip the first one.",
          "createdAt": "2022-01-28T22:28:24Z",
          "updatedAt": "2022-01-28T22:30:09Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I personally prefer the original text here, sorry.",
              "createdAt": "2022-01-28T22:28:24Z",
              "updatedAt": "2022-01-28T22:30:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7Ms4zqdvy",
          "commit": {
            "abbreviatedOid": "94c25d8"
          },
          "author": "kaduk",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-28T22:37:44Z",
          "updatedAt": "2022-01-28T22:37:44Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "The motivation for any change here is that the original text sounds like the (reliable) control data is being supported by the unreliable datagrams, which seems unlikely to be the expected use.\r\nOther options include \"by augmenting reliable streams with unreliable datagrams\", \"could extend from the former to the latter by using unreliable datagrams\", etc.",
              "createdAt": "2022-01-28T22:37:44Z",
              "updatedAt": "2022-01-28T22:37:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7Ms4zqe6M",
          "commit": {
            "abbreviatedOid": "94c25d8"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-28T22:47:01Z",
          "updatedAt": "2022-01-28T22:47:02Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "How about `with the use of unreliable datagrams in addition to reliable streams`?",
              "createdAt": "2022-01-28T22:47:01Z",
              "updatedAt": "2022-01-28T22:47:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7Ms4zqfCv",
          "commit": {
            "abbreviatedOid": "94c25d8"
          },
          "author": "kaduk",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-28T22:48:04Z",
          "updatedAt": "2022-01-28T22:48:04Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "sold",
              "createdAt": "2022-01-28T22:48:04Z",
              "updatedAt": "2022-01-28T22:48:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7Ms4zqgGo",
          "commit": {
            "abbreviatedOid": "ef311c1"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2022-01-28T22:56:59Z",
          "updatedAt": "2022-01-28T22:56:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 77,
      "id": "PR_kwDODoD7Ms4x-WF0",
      "title": "Grammar nit from Murray",
      "url": "https://github.com/quicwg/datagram/pull/77",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2022-02-02T15:29:26Z",
      "updatedAt": "2022-02-02T17:30:13Z",
      "baseRepository": "quicwg/datagram",
      "baseRefName": "main",
      "baseRefOid": "2081d908f347a1ff5160ed580422d35ceafd5526",
      "headRepository": "quicwg/datagram",
      "headRefName": "tfpauly-patch-1",
      "headRefOid": "f22aa94791aecb8445ff2ff4a15e8c33e2a612a6",
      "closedAt": "2022-02-02T17:30:12Z",
      "mergedAt": "2022-02-02T17:30:12Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "df26a38a07f4aa7f649222e9c7fa52a96b02619c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD7Ms4z5v4R",
          "commit": {
            "abbreviatedOid": "f22aa94"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-02T16:08:41Z",
          "updatedAt": "2022-02-02T16:08:41Z",
          "comments": []
        }
      ]
    },
    {
      "number": 78,
      "id": "PR_kwDODoD7Ms4x-xKa",
      "title": "Address John Scudder's AD comments",
      "url": "https://github.com/quicwg/datagram/pull/78",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2022-02-02T17:23:59Z",
      "updatedAt": "2022-02-02T18:39:49Z",
      "baseRepository": "quicwg/datagram",
      "baseRefName": "main",
      "baseRefOid": "2081d908f347a1ff5160ed580422d35ceafd5526",
      "headRepository": "quicwg/datagram",
      "headRefName": "tfpauly-patch-3",
      "headRefOid": "e59c6b588d1243b57069ada62c17281dd3071378",
      "closedAt": "2022-02-02T18:39:48Z",
      "mergedAt": "2022-02-02T18:39:48Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "83f6b3beebe5317e7941b279261ea240780158da"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD7Ms4z6JZQ",
          "commit": {
            "abbreviatedOid": "20bacbe"
          },
          "author": "ekinnear",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thank you!",
          "createdAt": "2022-02-02T17:25:57Z",
          "updatedAt": "2022-02-02T17:27:02Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Very nice ",
              "createdAt": "2022-02-02T17:25:57Z",
              "updatedAt": "2022-02-02T17:27:02Z"
            },
            {
              "originalPosition": 19,
              "body": "Could expand the parenthetical here if it would help clarify the `X`, but seems fine either way.",
              "createdAt": "2022-02-02T17:26:55Z",
              "updatedAt": "2022-02-02T17:27:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7Ms4z6J2S",
          "commit": {
            "abbreviatedOid": "20bacbe"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-02T17:27:23Z",
          "updatedAt": "2022-02-02T17:28:11Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I really like this new phrasing, though the comparison to TLS was useful, how about we tweak the last sentence of this paragraph to: `This can reduce the latency required for handshakes compared to opening both a TLS connection and a DTLS connection .`",
              "createdAt": "2022-02-02T17:27:23Z",
              "updatedAt": "2022-02-02T17:28:11Z"
            },
            {
              "originalPosition": 20,
              "body": "```suggestion\r\nis the LEN bit (0x01), which indicates whether there is a Length field present: if this\r\n```",
              "createdAt": "2022-02-02T17:28:02Z",
              "updatedAt": "2022-02-02T17:29:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7Ms4z6KZ2",
          "commit": {
            "abbreviatedOid": "20bacbe"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-02T17:29:16Z",
          "updatedAt": "2022-02-02T17:29:17Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\n  This can reduce the latency required for handshakes compared to opening both\r\n  a TLS connection and a DTLS connection.\r\n```",
              "createdAt": "2022-02-02T17:29:16Z",
              "updatedAt": "2022-02-02T17:29:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7Ms4z6K6O",
          "commit": {
            "abbreviatedOid": "03ea61a"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-02T17:31:04Z",
          "updatedAt": "2022-02-02T17:31:05Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "```suggestion\r\nis the LEN bit (0x01), which indicates whether there is a Length field present: if this\r\n```",
              "createdAt": "2022-02-02T17:31:04Z",
              "updatedAt": "2022-02-02T17:31:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7Ms4z6LID",
          "commit": {
            "abbreviatedOid": "03ea61a"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-02T17:31:48Z",
          "updatedAt": "2022-02-02T17:31:48Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "```suggestion\r\nto the end of the packet; if this bit is set to 1, the Length field is present.\r\n```",
              "createdAt": "2022-02-02T17:31:48Z",
              "updatedAt": "2022-02-02T17:31:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7Ms4z6LS7",
          "commit": {
            "abbreviatedOid": "03ea61a"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-02T17:32:22Z",
          "updatedAt": "2022-02-02T17:32:22Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODoD7Ms4z6NCi",
          "commit": {
            "abbreviatedOid": "e59c6b5"
          },
          "author": "ekinnear",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-02T17:38:32Z",
          "updatedAt": "2022-02-02T17:38:33Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Making them match\r\n```suggestion\r\nis the LEN bit (0x01), which indicates whether there is a Length field present; if this\r\n```",
              "createdAt": "2022-02-02T17:38:32Z",
              "updatedAt": "2022-02-02T17:38:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7Ms4z6Nvt",
          "commit": {
            "abbreviatedOid": "e59c6b5"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-02T17:41:05Z",
          "updatedAt": "2022-02-02T17:41:06Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Eh I like the colon. Let's let the RFC ed deal with this.",
              "createdAt": "2022-02-02T17:41:05Z",
              "updatedAt": "2022-02-02T17:41:06Z"
            }
          ]
        }
      ]
    },
    {
      "number": 79,
      "id": "PR_kwDODoD7Ms4x_IOY",
      "title": "Suggestion from Murray",
      "url": "https://github.com/quicwg/datagram/pull/79",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-02-02T19:30:33Z",
      "updatedAt": "2022-02-02T19:44:31Z",
      "baseRepository": "quicwg/datagram",
      "baseRefName": "main",
      "baseRefOid": "83f6b3beebe5317e7941b279261ea240780158da",
      "headRepository": "quicwg/datagram",
      "headRefName": "tfpauly-patch-1",
      "headRefOid": "6ddba95f8fd988aedd66dd43749082d265046b83",
      "closedAt": "2022-02-02T19:44:31Z",
      "mergedAt": "2022-02-02T19:44:31Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "1b946464f5921f4acdedf5927a74d16b31054348"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD7Ms4z6qEH",
          "commit": {
            "abbreviatedOid": "aebea1c"
          },
          "author": "ekinnear",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-02T19:32:48Z",
          "updatedAt": "2022-02-02T19:32:54Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\ncontrol, described below) and MAY be coalesced with other frames.\r\n```",
              "createdAt": "2022-02-02T19:32:48Z",
              "updatedAt": "2022-02-02T19:32:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODoD7Ms4z6rYR",
          "commit": {
            "abbreviatedOid": "6ddba95"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-02T19:37:54Z",
          "updatedAt": "2022-02-02T19:37:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 80,
      "id": "PR_kwDODoD7Ms4yCzK-",
      "title": "Editorial nits",
      "url": "https://github.com/quicwg/datagram/pull/80",
      "state": "MERGED",
      "author": "ekinnear",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Purely editorial nits",
      "createdAt": "2022-02-03T18:35:47Z",
      "updatedAt": "2022-02-03T18:38:11Z",
      "baseRepository": "quicwg/datagram",
      "baseRefName": "main",
      "baseRefOid": "1b946464f5921f4acdedf5927a74d16b31054348",
      "headRepository": "quicwg/datagram",
      "headRefName": "ek/editorial",
      "headRefOid": "95c2155155816978e478b84b45213b98b374ffce",
      "closedAt": "2022-02-03T18:38:10Z",
      "mergedAt": "2022-02-03T18:38:10Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "315a6d82c4b185d2f2790224f183b66d51c0f40a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD7Ms4z_a72",
          "commit": {
            "abbreviatedOid": "95c2155"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-03T18:38:06Z",
          "updatedAt": "2022-02-03T18:38:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 85,
      "id": "PR_kwDODoD7Ms41hQmZ",
      "title": "Changes from AUTH48",
      "url": "https://github.com/quicwg/datagram/pull/85",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR contains all the diff that were made by the RFC editor and authors during RFC edition and AUTH48.\r\n\r\nThe diff between this PR's txt representation and the RFC txt can be seen [here](https://www.ietf.org/rfcdiff?url1=https://quicwg.github.io/datagram/auth48/draft-ietf-quic-datagram.txt&url2=https://www.rfc-editor.org/rfc/rfc9221.txt).\r\n\r\nCloses #81 \r\nCloses #82 \r\nCloses #83 \r\nCloses #84 ",
      "createdAt": "2022-04-02T00:57:53Z",
      "updatedAt": "2022-04-03T18:23:37Z",
      "baseRepository": "quicwg/datagram",
      "baseRefName": "main",
      "baseRefOid": "65db4356820222b5c44d863f3770b3d95096f307",
      "headRepository": "quicwg/datagram",
      "headRefName": "auth48",
      "headRefOid": "3e195ab65242dd54cda5175af034b6e8fef27714",
      "closedAt": "2022-04-03T18:23:36Z",
      "mergedAt": "2022-04-03T18:23:36Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "8860bc4f2abb993e6e8ef9e45651a8190d86e489"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODoD7Ms43ZzNU",
          "commit": {
            "abbreviatedOid": "3e195ab"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-04-02T02:11:57Z",
          "updatedAt": "2022-04-02T02:11:57Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODoD7Ms43aCQd",
          "commit": {
            "abbreviatedOid": "3e195ab"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-04-02T13:40:41Z",
          "updatedAt": "2022-04-02T13:40:41Z",
          "comments": []
        }
      ]
    }
  ]
}